<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="A website built through Hugo and blogdown.">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>


    
      <link href="https://fonts.googleapis.com/css?family=Open+Sans:400|Old+Standard+TT:400&display=swap" rel="stylesheet" media="print" type="text/css" onload="this.media='all'">
    

    


<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />




    <title>
      
      
         hclust 对象里究竟有什么？ 
      
    </title>
    <link rel="canonical" href="lab-cn/2023/07/07/what-is-a-hclust-object/">

    <style>
  * {
    border:0;
    font:inherit;
    vertical-align:baseline;
    margin:0;
    padding:0;
    color: black;
    text-decoration-skip: ink;
    overflow-wrap: break-word;
  }

  body {
    font-family: Georgia,serif;
    line-height:160%;
    color:#1d1313;
    max-width:1000px;
    margin:auto;
    min-height: 600px;
    font-size: 17px;
  }

  p {
    margin: 20px 0;
  }

  a img {
    border:none;
  }

  img {
    margin: 10px auto 10px auto;
    max-width: 100%;
    display: block;
  }

  .left-justify { float: left; }
  .right-justify { float:right; }

  pre, code {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    background-color: #f7f7f7;
  }

  code {
    padding: 4px;
  }

  pre {
    margin-top: 0;
    margin-bottom: 16px;
    word-wrap: normal;
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
  }

  pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
  }

  pre code {
    display: inline;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
  }

  pre code::before,
  pre code::after {
    content: normal;
  }

  em,q,em,dfn {
    font-style:italic;
  }

  .sans,html .gist .gist-file .gist-meta {
    font-family:"Open Sans","Myriad Pro",Myriad,sans-serif;
  }

  .mono,pre,code,tt,p code,li code {
    font-family:Menlo,Monaco,"Andale Mono","lucida console","Courier New",monospace;
  }

  strong {
    font-weight:600;
  }

  q:before {
    content:"\201C";
  }

  q:after {
    content:"\201D";
  }

  del,s {
    text-decoration:line-through;
  }

  blockquote {
    font-family:"Old Standard TT",serif;
    text-align:center;
    padding:50px;
  }

  blockquote p {
    display:inline-block;
    font-style:italic;
  }

  blockquote:before,blockquote:after {
    font-family:"Old Standard TT",serif;
    content:'\201C';
    color:#403c3b;
  }

  blockquote:after {
    content:'\201D';
  }

  hr {
    width:40%;
    height: 1px;
    background:#403c3b;
    margin: 25px auto;
  }


  h2, h3 {
    margin-top: 40px;
    margin-bottom: 20px;
  }

  h1 a,h2 a,h3 a {
    text-decoration:none;
  }

  h1,h2 {
    margin-top:28px;
  }

  h1 {
    font-size: 2em;
  }

  h2, h3 {
    font-size: 1.5em;
  }

  #sub-header, .date {
    color:#403c3b;
  }

  #sub-header {
    margin: 0 4px;
    font-style: italic;
  }

  #nav h1 a {
    color:#1d1313;
    line-height:120%;
  }

  .posts_listing a,#nav a {
    text-decoration: none;
  }

  li {
    margin-left: 20px;
  }

  ul li {
    margin-left: 20px;
    padding-top: 2px;
    padding-bottom: 2px;
  }


  #nav ul li:before, .posts_listing li:before {
    content:'';
    margin-right:0;
  }

  #content {
    text-align:left;
    width:100%;
    padding:30px 0 80px;
  }

  #content h1,#content h2 {
    margin-bottom:5px;
  }

  #content .entry-content {
    margin-top:15px;
  }

  #content .date {
    margin-left:3px;
  }


  .highlight {
    margin: 10px 0;
  }

  .posts_listing {
    margin:0 0 50px;
  }

  .posts_listing li {
    margin:0 0 25px 15px;
  }

 
  #nav {
    text-align:center;
    position:static;
    margin-top:60px;
  }

  a {
    text-decoration: underline;
    text-decoration-color: #CCC;
    text-underline-offset: 5px;
  }

  a:hover {
    text-decoration-color: black;
  }

  
  #nav li {
    list-style-type:none;
    display:table-cell;
    padding: 0 20px;
  }

  #links {
    display: flex;
    justify-content: space-between;
    margin: 50px 0 0 0;
  }

  #links :nth-child(1) {
    margin-right:0.5em;;
  }

  #links :nth-child(2) {
    margin-left:0.5em;;
  }

  #not-found {
    text-align: center;
  }

  #not-found a {
    font-size: 3em;
    text-decoration: none;
    display: inline-block;
    padding-top: 225px;
    padding-bottom: 225px;
  }


#soft-info table td {
  padding: 2px 10px 2px 0px;
}

#license {
  font-style: italic;
  padding-top: 10px;
  padding-bottom: 10px;
  color:#403c3b;
}
#license a {
  color:#403c3b;
}
  @media (max-width: 750px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:28px;
    }

    #nav li {
      font-size:13px;
      padding: 0 5px;
    }

    #content {
      margin-top:0;
      padding-top:50px;
      font-size:14px;
    }

    #content h1 {
      font-size:25px;
    }

    #content h2 {
      font-size:22px;
    }

    .posts_listing li div {
      font-size:12px;
    }
  }

  @media (max-width: 400px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:22px;
    }

    #nav li {
      font-size:12px;
      padding: 0 5px;
    }

    #content {
      margin-top:0;
      padding-top:20px;
      font-size:12px;
    }

    #content h1 {
      font-size:20px;
    }

    #content h2 {
      font-size:18px;
    }

    .posts_listing li div{
      font-size:12px;
    }
  }

  @media (prefers-color-scheme: dark) {
    *, #nav h1 a {
      color: #FDFDFD;
    }

    body {
      background: #121212;
    }

    pre, code {
      background-color: #262626;
    }

    #sub-header, .date {
      color: #BABABA;
    }

    hr {
      background: #EBEBEB;
    }
  }
</style>


    </head>
<style>
#nav-logo-text {
    float: left;
    margin-top: 0px;
    margin-left: 0px;
    font-size: 2em;
    font-weight: 100;
}
#at {
  font-size:24px;
  padding:0px 2px;
}
</style>
<script>
window.root_dir = "lab-cn\/";
const regex = /^https?:\/\/[^/]+?\//;
root_dir = root_dir.replace(regex, "/");
$( function() {
  $("#content img").each(function(i) {
        var old_src = $(this).attr("src");
        var pattern = new RegExp("^" + root_dir);
        if(!pattern.test(old_src)) {
            pattern = /^http(s?):\/\//;
            if(!pattern.test(old_src)) {
                $(this).attr("src", root_dir + "/" + old_src);
            }
        }
    });
  $("#nav-logo-text").attr("href", root_dir);
  $("#no-found-a").attr("href", root_dir);

  var url = window.location.href;
  var pattern = /lab-cn/;
  var url2 = url.replace(pattern, "lab-en");
  $("#nav ul li:last-child a").attr("href", url2);
})
</script>
  <body>
    <section id=nav>
      <h1><a class="h-card" href="/"></a></h1>
      <a href="#" id="nav-logo-text">Gu<span style="padding:0px 2px">.</span>Z<span id="at">@</span>SUAT-SZ</a>
      <ul style="float:right">
        
          <li><a href="lab-cn/research/">研究</a></li>
        
          <li><a href="lab-cn/publication/">论文</a></li>
        
          <li><a href="lab-cn/software/">软件</a></li>
        
          <li><a href="lab-cn/post">博客</a></li>
        
          <li><a href="lab-cn/members/">成员</a></li>
        
          <li><a href="lab-cn/opening/">职位</a></li>
        
          <li><a href="lab-en/">EN</a></li>
        
      </ul>
      <div style="clear:both"></div>
    </section>


<section id=content>
  <h1 style="margin-bottom: 40px"> hclust 对象里究竟有什么？ </h1>

  
    <div id=sub-header>
      顾祖光 · July 2023 · <a href="#license">版权信息</a>
    </div>
  

  <div class="entry-content">
    <p>等级聚类或者层级聚类是常用的数据分析方法，在R中，我们使用<code>hclust()</code>函数进行聚类分析。<code>hclust()</code>返回一个<code>hclust</code>类的对象。在本文中，让我们来揭开<code>hclust</code>对象的真面目。</p>
<p>首先生成一个随机的5x5矩阵，我们对矩阵的行进行聚类。</p>
<pre><code class="language-r">set.seed(123456)
m = matrix(rnorm(25), 5)
rownames(m) = letters[1:5]
hc = hclust(dist(m))
</code></pre>
<p><code>hc</code>属于一个<code>hclust</code>的类。输入<code>hc</code>变量名打印出这个变量的一些基本信息。</p>
<pre><code class="language-r">hc
</code></pre>
<pre><code>## 
## Call:
## hclust(d = dist(m))
## 
## Cluster method   : complete 
## Distance         : euclidean 
## Number of objects: 5
</code></pre>
<p>基本上就告诉你这是一个黑盒子，不告诉你其内部的结构。使用<code>plot()</code>函数可以绘制聚类图。</p>
<pre><code class="language-r">plot(hc)
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-4-1.png" width="480" style="display: block; margin: auto;" />
<p>上面这两步是最标准的进行等级聚类分析的步骤，那么，<code>hc</code>变量中到底存储着什么信息呢？
本文就来揭示这个<code>hc</code>变量的内部结构。在遇到任何一个未知格式的对象时，一般我们使用<code>str()</code>来展示其内部结构：</p>
<pre><code class="language-r">str(hc)
</code></pre>
<pre><code>## List of 7
##  $ merge      : int [1:4, 1:2] -3 -1 1 -5 -4 -2 2 3
##  $ height     : num [1:4] 2.01 2.48 3.51 4.11
##  $ order      : int [1:5] 5 3 4 1 2
##  $ labels     : chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
##  $ method     : chr &quot;complete&quot;
##  $ call       : language hclust(d = dist(m))
##  $ dist.method: chr &quot;euclidean&quot;
##  - attr(*, &quot;class&quot;)= chr &quot;hclust&quot;
</code></pre>
<p>可以看到，<code>hc</code>只是一个包含7个成员的简单列表。最后三个成员<code>method</code>，<code>call</code>和<code>dist.method</code>只是关于此变量的一些文字标记，我们跳过不谈。我们主要看前四个成员。</p>
<p>为了正确理解<code>hc</code>的格式，我们要对其中成员向量或者矩阵的顺序额外注意。我们首先介绍<code>labels</code>和<code>order</code>成员。</p>
<pre><code class="language-r">hc$labels
</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;
</code></pre>
<pre><code class="language-r">hc$order
</code></pre>
<pre><code>## [1] 5 3 4 1 2
</code></pre>
<p><code>labels</code>成员包含了原始变量的文字标签，其顺序和原始变量的顺序一致。在这里<code>hc</code>是来源于矩阵<code>m</code>，那么<code>labels</code>中值的顺序和<code>m</code>行的顺序一致。如果原始矩阵没有行名的话，<code>labels</code>是一个长度为零的向量。</p>
<p><code>order</code>的顺序和<code>labels</code>不一样。等级聚类会对变量进行重排序，那么<code>order</code>中记录了排完序之后变量的下标。</p>
<pre><code class="language-r">hc$order
</code></pre>
<pre><code>## [1] 5 3 4 1 2
</code></pre>
<p>第一个元素表示聚完类后，变量5在第一个位置上，变量3在第二个位置上，以此类推。如果我们使用原始矩阵的行名的话，聚类之后的顺序为：</p>
<pre><code class="language-r">hc$labels[hc$order]
</code></pre>
<pre><code>## [1] &quot;e&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot;
</code></pre>
<p>也就是说，聚类之后，变量<code>&quot;e&quot;</code>在最左侧，然后分别是<code>&quot;c&quot;</code>, <code>&quot;d&quot;</code>, <code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>。</p>
<p>现在让我们来看看<code>merge</code>和<code>height</code>成员。</p>
<pre><code class="language-r">hc$merge
</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   -3   -4
## [2,]   -1   -2
## [3,]    1    2
## [4,]   -5    3
</code></pre>
<pre><code class="language-r">hc$height
</code></pre>
<pre><code>## [1] 2.014138 2.478801 3.507676 4.113743
</code></pre>
<p>第一眼看<code>hc$merge</code>，我们可能会说这是什么鬼，既有正的整数，又有负的整数。其实，<code>merge</code>使用不同的符号来表示聚类过程中不同类型的“节点”，比如说，这是一个变量/叶节点呢，还是一个子聚类/子树节点？</p>
<p>首先我们要知道，<code>hclust()</code>执行的是聚集式的聚类方式，也就是自底而上的方式。下图展示了<code>hc</code>中的四步聚类：</p>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-10-1.png" width="768" style="display: block; margin: auto;" />
<p>那么，其实<code>merge</code>中记录了聚类的步骤，第一行为聚类的第一步，第二行为聚类的第二步。每一行包含两个数据，表示把两个子节点聚成一类。其中如果值为负数时，这表示这是一个变量（或叶节点），那么其绝对值对应着这个变量的下标（第几号变量）；如果值为正数的话，这表示这是一个子树，值对应着子树在<code>merge</code>中的下标（第几号子树）。</p>
<p>现在<code>merge</code>可以读作：</p>
<pre><code class="language-r">hc$merge
</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   -3   -4
## [2,]   -1   -2
## [3,]    1    2
## [4,]   -5    3
</code></pre>
<ul>
<li>聚类第一步/<code>merge</code>中第一行：变量3（<code>&quot;c&quot;</code>)和变量4（<code>&quot;d&quot;</code>）聚成一类。这个子树（或者可以看成变量3和4的父节点）的编号为1（因为是<code>merge</code>中的第一行）。</li>
<li>聚类第二步/<code>merge</code>中第二行：变量1（<code>&quot;a&quot;</code>)和变量2（<code>&quot;b&quot;</code>）聚成一类。这个子树的编号为2。</li>
<li>聚类第三步/<code>merge</code>中第三行：现在这行的两个数字都是正数，这表示要合并的两个都是聚类的子树，编号为1和2。这两个在前两步已经生成。</li>
<li>聚类第四步/<code>merge</code>中第四行：这里有一个负数和一个正数，这表示要合并的是一个变量（变量5，<code>&quot;e&quot;</code>）和一个子树（编号为3，在第三步中生成）。</li>
</ul>
<p><code>hc$height</code>中的元素和<code>hc$merge</code>中的行对应，就是每一个子树的高度。</p>
<p>现在看来，<code>hclust</code>对象的格式还是很简单的。</p>
<p>我们可以试着基于<code>hc</code>的内部格式绘制聚类图。让我们按照<code>hc$merge</code>中所记录的聚类的步骤一步一步来绘制。</p>
<p>第一步是绘制合并3号变量和4号变量的子树，我们知道这个子树的高度是<code>hc$height[1]</code>，但是现在缺的是这些变量或者子树在x轴上的位置。这些位置很容易获得。</p>
<p>我们知道下面标签的顺序和聚类图上的顺序一致：</p>
<pre><code class="language-r">hc$labels[hc$order]
</code></pre>
<pre><code>## [1] &quot;e&quot; &quot;c&quot; &quot;d&quot; &quot;a&quot; &quot;b&quot;
</code></pre>
<p>也就是说，<code>&quot;e&quot;</code>在位置1，<code>&quot;c&quot;</code>在位置2，&hellip; 但是这五个标签的顺序并不是原始顺序。在<code>hc$merge</code>中，其中的整数对应的是变量的原始顺序，例如-2表示在原始顺序中的2号变量。那么我们需要一个变量，其中记录着每个变量在聚类图上的位置，并且处于原始顺序中（也就是对应<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, <code>&quot;c&quot;</code>, <code>&quot;d&quot;</code>, <code>&quot;e&quot;</code>）。</p>
<p>我们可以首先创建一个有名字的向量，其中聚类之后的位置为值，名字为变量的标签。</p>
<pre><code class="language-r"># 1:5 是在x轴上的位置
map = structure(1:5, names = hc$labels[hc$order])
# 然后我们用这个有名字的向量获得对应原始顺序的变量
x = map[hc$labels]
x
</code></pre>
<pre><code>## a b c d e 
## 4 5 2 3 1
</code></pre>
<p>其实我们可以直接取<code>hc$order</code>的order获得这个向量。</p>
<pre><code class="language-r">x = order(hc$order)
x
</code></pre>
<pre><code>## [1] 4 5 2 3 1
</code></pre>
<p>看起来有点绕，什么叫order的order？在<code>hc$order</code>中，值是变量的原始下标（也就是第几个变量），<code>hc$order</code>的下标（也就是1, 2, 3, 4, 5）对应着在聚完类后变量在x轴上的位置。</p>
<pre><code>hc$order
  value 5 3 4 1 2  # indices of items, i.e. item 5, item 3, ...
  pos   1 2 3 4 5  # pos in x-axis in the plot
</code></pre>
<p>那么如果我们对<code>hc$order</code>（值为<code>5, 3, 4, 1, 2</code>）进行第二次<code>order()</code>时，在返回的变量中，第一个值是<code>5, 3, 4, 1, 2</code>中最小值的位置，就是1（1号变量）的位置是4（这个4是变量1在x轴上的位置），第二个值就是2（2号变量）的位置是5（变量2在x轴上的位置）。以此类推。这就意味着，<code>order(hc$order)</code>能够返回变量在聚类图上的位置，并且处于原始顺序中。</p>
<p>OK，现在我们有了所有的信息，可以一步一步的绘制聚类图了。我们按照<code>hc$merge</code>中的顺序：</p>
<p>第一步/对应着<code>hc$merge</code>中的第一行，我们画一条线连接3号变量（<code>&quot;c&quot;</code>）和4号变量（<code>&quot;d&quot;</code>）。</p>
<pre><code class="language-r">plot(NULL, xlim = c(0.5, 5.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
axis(side = 1, at = 1:5, labels = hc$labels[hc$order])
axis(side = 2)

# the first row in `merge` is '[1,]   -3   -4'
segments(x[3], hc$height[1], x[4], hc$height[1])
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-15-1.png" width="480" style="display: block; margin: auto;" />
<p>第二步/对应着<code>hc$merge</code>中的第二行，我们画一条线连接1号变量（<code>&quot;a&quot;</code>）和2号变量（<code>&quot;b&quot;</code>）。</p>
<pre><code class="language-r">plot(NULL, xlim = c(0.5, 5.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
axis(side = 1, at = 1:5, labels = hc$labels[hc$order])
axis(side = 2)

segments(x[3], hc$height[1], x[4], hc$height[1])
# the second row in `merge` is '[2,]   -1   -2'
segments(x[1], hc$height[2], x[2], hc$height[2])
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-16-1.png" width="480" style="display: block; margin: auto;" />
<p>第三步/对应着<code>hc$merge</code>中的第三行。现在这里有个新情况，第三步我们需要合并两个子树，我们通常连接两个子树的中点。计算子树1和子树2的中点很容易。子树1的中点就是其两个子节点（变量3和变量4）的中点，子树2的中点就是其两个子节点（变量1和变量2）的中点。</p>
<p>在下面的代码中，变量<code>midpoint</code>记录了中点的位置。</p>
<pre><code class="language-r">plot(NULL, xlim = c(0.5, 5.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
axis(side = 1, at = 1:5, labels = hc$labels[hc$order])
axis(side = 2)

segments(x[3], hc$height[1], x[4], hc$height[1])
segments(x[1], hc$height[2], x[2], hc$height[2])

midpoint = numeric(0)
midpoint[1] = (x[3]+x[4])/2
midpoint[2] = (x[1]+x[2])/2

# the third row in `merge` is '[3,]    1    2'
segments(midpoint[1], hc$height[3], midpoint[2], hc$height[3])
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-17-1.png" width="480" style="display: block; margin: auto;" />
<p>第四步/对应着<code>hc$merge</code>中的第四行。这一步合并5号变量和3号子树，同样我们需要先获得3号子树的中点（3号子树的中点是其两个子节点中点<code>midpoint[1]</code>和<code>midpoint[2]</code>的中点，看代码一目了然）。</p>
<pre><code class="language-r">plot(NULL, xlim = c(0.5, 5.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
axis(side = 1, at = 1:5, labels = hc$labels[hc$order])
axis(side = 2)

segments(x[3], hc$height[1], x[4], hc$height[1])
segments(x[1], hc$height[2], x[2], hc$height[2])

midpoint = numeric(0)
midpoint[1] = (x[3]+x[4])/2
midpoint[2] = (x[1]+x[2])/2

segments(midpoint[1], hc$height[3], midpoint[2], hc$height[3])

midpoint[3] = (midpoint[1] + midpoint[2])/2
# the third row in `merge` is '[4,]   -5    3'
segments(x[5], hc$height[4], midpoint[3], hc$height[4])
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-18-1.png" width="480" style="display: block; margin: auto;" />
<p>我们可以添加垂直的线条，让其看起来像一个完整的聚类树。</p>
<pre><code class="language-r">plot(NULL, xlim = c(0.5, 5.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
axis(side = 1, at = 1:5, labels = hc$labels[hc$order])
axis(side = 2)

segments(x[3], hc$height[1], x[4], hc$height[1])
segments(x[3], 0, x[3], hc$height[1])
segments(x[4], 0, x[4], hc$height[1])

segments(x[1], hc$height[2], x[2], hc$height[2])
segments(x[1], 0, x[1], hc$height[2])
segments(x[2], 0, x[2], hc$height[2])

midpoint = numeric(0)
midpoint[1] = (x[3]+x[4])/2
midpoint[2] = (x[1]+x[2])/2

segments(midpoint[1], hc$height[3], midpoint[2], hc$height[3])
segments(midpoint[1], hc$height[3], midpoint[1], hc$height[1])
segments(midpoint[2], hc$height[3], midpoint[2], hc$height[2])

midpoint[3] = (midpoint[1] + midpoint[2])/2
segments(x[5], hc$height[4], midpoint[3], hc$height[4])
segments(midpoint[3], hc$height[4], midpoint[3], hc$height[3])
segments(x[5], 0, x[5], hc$height[4])
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-19-1.png" width="480" style="display: block; margin: auto;" />
<p>为了重复利用上面的代码，我们可以把它们放在一个函数中。这个函数<code>plot_hc()</code>很简单，其中四个<code>if-else</code>代码块处理下面四个不同的条件：</p>
<ol>
<li>两个子节点都是变量（或者叶节点）</li>
<li>左子节点是叶节点，右子节点是一个子树</li>
<li>左子节点是一个子树，右子节点是叶节点</li>
<li>两个子节点都是子树</li>
</ol>
<pre><code class="language-r">plot_hc = function(hc) {
    x = order(hc$order)
    nobs = length(x)

    if(length(hc$labels) == 0) {
        hc$labels = as.character(seq_along(hc$order))
    }

    plot(NULL, xlim = c(0.5, nobs + 0.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
    axis(side = 1, at = 1:nobs, labels = hc$labels[hc$order])
    axis(side = 2)
        
    merge = hc$merge
    order = hc$order
    nr = nrow(merge)
    midpoint = numeric(nr)

    for(i in seq_len(nr)) {
        child1 = merge[i, 1]
        child2 = merge[i, 2]

        if(child1 &lt; 0 &amp;&amp; child2 &lt; 0) { # both are leaves
            segments(x[ -child1 ], 
                     hc$height[i],
                     x[ -child2 ], 
                     hc$height[i])
            midpoint[i] = (x[ -child1 ] + x[ -child2 ])/2
            segments(x[ -child1 ], hc$height[i], x[ -child1 ], 0)
            segments(x[ -child2 ], hc$height[i], x[ -child2 ], 0)
        } else if(child1 &lt; 0 &amp;&amp; child2 &gt; 0) {
            segments(x[ -child1 ], 
                     hc$height[i],
                     midpoint[ child2 ], 
                     hc$height[i])
            midpoint[i] = (x[ -child1 ] + midpoint[ child2 ])/2
            segments(x[ -child1 ], hc$height[i], x[ -child1 ], 0)
            segments(midpoint[ child2 ], hc$height[i], midpoint[ child2 ], hc$height[ child2 ])
        } else if(merge[i, 1] &gt; 0 &amp;&amp; merge[i, 2] &lt; 0) {
            segments(midpoint[ child1 ], 
                     hc$height[i],
                     x[ -child2 ], 
                     hc$height[i])
            midpoint[i] = (midpoint[ child1 ] + x[ -child2 ])/2
            segments(midpoint[ child1 ], hc$height[i], midpoint[ child1 ], hc$height[ child1 ])
            segments(x[ -child2 ], hc$height[i], x[ -child2 ], 0)
        } else {
            segments(midpoint[ child1 ], 
                     hc$height[i],
                     midpoint[ child2 ], 
                     hc$height[i])
            midpoint[i] = (midpoint[ child1 ] + midpoint[ child2 ])/2
            segments(midpoint[ child1 ], hc$height[i], midpoint[ child1 ], hc$height[ child1 ])
            segments(midpoint[ child2 ], hc$height[i], midpoint[ child2 ], hc$height[ child2 ])
        }
    }
}
</code></pre>
<p>我们试一试这个函数：</p>
<pre><code class="language-r">plot_hc(hc)
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-21-1.png" width="480" style="display: block; margin: auto;" />
<p>或者试一个更大的聚类结果：</p>
<pre><code class="language-r">m2 = matrix(rnorm(1000), nrow = 100)
hc2 = hclust(dist(m2))
plot_hc(hc2)
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-22-1.png" width="960" style="display: block; margin: auto;" />
<p>到这里，通常我们会有很大的成就感。因为<code>plot_hc()</code>是基于一个微小的数据测试和编写的，现在居然在很大的数据上能够成功运行。</p>
<p>下面我们来看，给定一个父节点(<code>top_x</code>, <code>top_y</code>)，和两个子节点(<code>left_x</code>, <code>left_y</code>)，(<code>right_x</code>, <code>right_y</code>)，我们来定义如何连接这三个节点。</p>
<p>默认的连接方式是连接下面四个点：</p>
<pre><code>x-coordinates: left_x, left_x, right_x, right_x
y-coordinates: left_y, top_y, top_y, right_y
</code></pre>
<p>在<code>plot_hc()</code>中，让我们将绘制父节点和子节点的代码抽象化。我们引入一个函数<code>parent_children_connections()</code>，其中我们可以自定义如何绘制连接方式。</p>
<pre><code class="language-r">plot_hc = function(hc) {
    x = order(hc$order)
    nobs = length(x)

    if(length(hc$labels) == 0) {
        hc$labels = as.character(seq_along(hc$order))
    }

    plot(NULL, xlim = c(0.5, nobs + 0.5), ylim = c(0, max(hc$height)*1.1), axes = FALSE, ann = FALSE)
    axis(side = 1, at = 1:nobs, labels = hc$labels[hc$order])
    axis(side = 2)
            
    merge = hc$merge
    order = hc$order
    height = hc$height
    nr = nrow(merge)
    midpoint = numeric(nr)

    for(i in seq_len(nr)) {
        child1 = merge[i, 1]
        child2 = merge[i, 2]

        if(child1 &lt; 0 &amp;&amp; child2 &lt; 0) { # both are leaves
            midpoint[i] = (x[ -child1 ] + x[ -child2 ])/2
            parent_children_connections(
                x[-child1], 0,
                midpoint[i], height[i],
                x[-child2], 0
            )
        } else if(child1 &lt; 0 &amp;&amp; child2 &gt; 0) {
            midpoint[i] = (x[ -child1 ] + midpoint[ child2 ])/2
            parent_children_connections(
                x[-child1], 0,
                midpoint[i], height[i],
                midpoint[child2], height[child2]
            )
        } else if(child1 &gt; 0 &amp;&amp; child2 &lt; 0) {
            midpoint[i] = (midpoint[ child1 ] + x[ -child2 ])/2
            parent_children_connections(
                midpoint[child1], height[child1],
                midpoint[i], height[i],
                x[-child2], 0
            )
        } else {
            midpoint[i] = (midpoint[ child1 ] + midpoint[ child2 ])/2
            parent_children_connections(
                midpoint[child1], height[child1],
                midpoint[i], height[i],
                midpoint[child2], height[child2]
            )
        }
    }
}
</code></pre>
<p>下面是默认的连接父节点和两个子节点的方式：</p>
<pre><code class="language-r">parent_children_connections = function(left_x, left_y, top_x, top_y, right_x, right_y) {
    lines(c(left_x, left_x, right_x, right_x),
          c(left_y, top_y, top_y, right_y))
}
plot_hc(hc)
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-24-1.png" width="480" style="display: block; margin: auto;" />
<p>我们可以定义一个新的方式，让连接方式呈三角形状：</p>
<pre><code>x-coordinates: left_x, top_x, right_x
y-coordinates: left_y, top_y, right_y
</code></pre>
<pre><code class="language-r">parent_children_connections = function(left_x, left_y, top_x, top_y, right_x, right_y) {
    lines(c(left_x, top_x, right_x),
          c(left_y, top_y, right_y))
}
plot_hc(hc)
</code></pre>
<img src="/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-25-1.png" width="480" style="display: block; margin: auto;" />
<p>同理，你可以自定义<code>parent_children_connections()</code>来实现其他连接方式，例如使用贝泽尔曲线。</p>
<p id="license">本文使用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans'>CC BY-NC-SA 4.0</a> 协议发布。</p>

  </div>


  <p id="license">本文使用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans'>CC BY-NC-SA 4.0</a> 协议发布。</p>


</section>


<style>
.footer p{
	color: #AAA;
	text-align: left;
	text-decoration: none;
	max-width:400px;
	border-top: 1px solid #AAA;
	padding-top:10px;
	font-size: 0.8em;
}
.footer p a {
	color: #AAA;
	text-align: left;
	text-decoration: none;
}
</style>

<footer class="footer">
<p>网站使用 <a href="https://gohugo.io/">Hugo</a>，<a href="https://bookdown.org/yihui/blogdown/">blogdown</a>，<a href="https://github.com/davidhampgonsalves/hugo-black-and-light-theme">Black & Light 主题</a>创建</p>
</footer>





<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>




<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>



