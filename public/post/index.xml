<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 深圳理工大学生物信息学课题组</title>
    <link>/lab-cn/post/</link>
    <description>Recent content in Posts on 深圳理工大学生物信息学课题组</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 16 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/lab-cn/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>提速 ORA 富集分析</title>
      <link>/lab-cn/2025/12/16/speed-up-over-representation-enrichment-analysis/</link>
      <pubDate>Tue, 16 Dec 2025 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2025/12/16/speed-up-over-representation-enrichment-analysis/</guid>
      <description>&lt;p&gt;富集分析，Over-representation analysis（ORA）是用来分析一个基因列表（例如差异基因，或者任意形式的基因列表，本文中我们以差异基因，也就是DE基因为例）是否富集在一个基因集合中的方法。我们一般使用超几何分布来计算&lt;em&gt;p&lt;/em&gt;值，对应的函数是&lt;code&gt;phyper()&lt;/code&gt;，参数为：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;phyper(x, m, n, k, lower.tail = FALSE)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;x&lt;/code&gt;是基因集合中DE基因的个数，&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;m&lt;/code&gt;是基因集合中基因的总数，&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;n&lt;/code&gt;是不属于此基因集合的基因总数，&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;k&lt;/code&gt;是DE基因的总数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;参数&lt;code&gt;lower.tail = FALSE&lt;/code&gt;计算的是$\mathrm{Pr}(X &amp;gt; x)$。在计算&lt;em&gt;p&lt;/em&gt;值时，我们常也包含$X = x$的情形，此时最终的&lt;em&gt;p&lt;/em&gt;值应当为$\mathrm{Pr}(X \ge x)$。那么在使用&lt;code&gt;phyper()&lt;/code&gt;时，我们需要将&lt;code&gt;x&lt;/code&gt;调整为&lt;code&gt;x - 1&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;phyper(x - 1, m, n, k, lower.tail = FALSE)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;使用forsapply循环&#34;&gt;使用for/sapply循环&lt;/h3&gt;&#xA;&lt;p&gt;已知一个DE基因列表和一个基因集合，很容易能够计算出&lt;code&gt;phyper()&lt;/code&gt;所需的四个参数的值。首先我们编写一个&lt;code&gt;ora_single()&lt;/code&gt;函数用来计算对一个单独基因集合做富集分析的&lt;em&gt;p&lt;/em&gt;值。如下代码所示，&lt;code&gt;ora_single()&lt;/code&gt;需要三个参数：一个DE基因向量&lt;code&gt;genes&lt;/code&gt;，一个基因集合基因向量&lt;code&gt;gene_set&lt;/code&gt;和一个背景基因向量&lt;code&gt;universe&lt;/code&gt;。在很多情况下，并不能保证背景基因能够完全包含DE基因或者基因集合，因此，我们需要手动去除不包含在背景基因中的基因（使用&lt;code&gt;intersect()&lt;/code&gt;函数）。&lt;/p&gt;&#xA;&lt;p&gt;在下面的例子中，我们假设所有的基因向量中的基因都具有相同类型的ID类型。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ora_single = function(genes, gene_set, universe) {&#xA;    n_universe = length(universe)&#xA;&#xA;    # 将genes和gene_set都限制在universe中&#xA;    genes = intersect(genes, universe)&#xA;    gene_set = intersect(gene_set, universe)&#xA;&#xA;    x = length(intersect(genes, gene_set)) # DE genes in the gene set&#xA;    m = length(gene_set)  # total genes in the gene set&#xA;    n = n_universe - m    # total genes not in the gene set&#xA;    k = length(genes)     # total DE genes&#xA;&#xA;    phyper(x - 1, m, n, k, lower.tail = FALSE)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后，对于一组基因集合，我们只需要使用&lt;code&gt;sapply()&lt;/code&gt;或者&lt;code&gt;for&lt;/code&gt;循环将&lt;code&gt;ora_single()&lt;/code&gt;应用到每一个基因集合上。在&lt;code&gt;ora_v1()&lt;/code&gt;中，我们假设基因集合的格式是一个list，其中每一个成员向量表示一个基因集合。&lt;code&gt;ora_v1()&lt;/code&gt;返回一个&lt;em&gt;p&lt;/em&gt;值向量。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Add backgroud grid lines to heatmap annotations</title>
      <link>/lab-cn/2025/04/01/add-backgroud-grid-lines-to-heatmap-annotations/</link>
      <pubDate>Tue, 01 Apr 2025 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2025/04/01/add-backgroud-grid-lines-to-heatmap-annotations/</guid>
      <description>&lt;p&gt;The question: for the following heatmap with a top barplot annotation, how to make it to a ggplot2-style plot, i.e., with background grid lines?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;&#xA;set.seed(666)&#xA;m = matrix(rnorm(100), 10)&#xA;x = abs(rnorm(10))&#xA;&#xA;Heatmap(m, top_annotation = HeatmapAnnotation(foo = anno_barplot(x), height = unit(8, &amp;quot;cm&amp;quot;)))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2025-04-01-add-background-grid-lines-to-heatmap-annotations_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;One natural solution is to use the &lt;code&gt;decorate_annotation()&lt;/code&gt; function to add such&#xA;additional graphics to the &amp;ldquo;foo&amp;rdquo; annotation. Just note&#xA;&lt;code&gt;decorate_annotation()&lt;/code&gt; is a post-processing function where the grey background will&#xA;overwrite the bars in the annotation. Thus, we need to redraw the bars after&#xA;the background grid lines are drawn.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Edit grobs in ggplot2 plots</title>
      <link>/lab-cn/2024/05/16/edit-grobs-in-ggplot2-plots/</link>
      <pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2024/05/16/edit-grobs-in-ggplot2-plots/</guid>
      <description>&lt;p&gt;Load the packages and generate test dataset.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)&#xA;library(grid)&#xA;df = data.frame(&#xA;    x = rep(c(2, 5, 7, 9, 12), 2),&#xA;    y = rep(c(1, 2), each = 5),&#xA;    z = factor(rep(1:5, each = 2)),&#xA;    w = rep(diff(c(0, 4, 6, 8, 10, 14)), 2)&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We make a &amp;ldquo;heatmap&amp;rdquo; with the &lt;strong&gt;ggplot2&lt;/strong&gt; package.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(df, aes(x, y)) +&#xA;    geom_tile(aes(fill = z), color = NA)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2024-05-16-edit-grobs-in-ggplot2-plots_files/figure-html/unnamed-chunk-3-1.svg&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;Depends on the &amp;ldquo;graphics device&amp;rdquo; you use, you might see white vertical and horizontal lines between cells in the plot. Here in&#xA;this example I use &amp;ldquo;svg&amp;rdquo;, but there is no such problem with other devices such as &amp;ldquo;png&amp;rdquo; or &amp;ldquo;jpeg&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Get gene-region associations for a group of GO terms</title>
      <link>/lab-cn/2024/02/05/get-gene-region-associations-for-a-group-of-go-terms/</link>
      <pubDate>Mon, 05 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2024/02/05/get-gene-region-associations-for-a-group-of-go-terms/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s first do a combination analysis with &lt;strong&gt;rGREAT&lt;/strong&gt; and &lt;strong&gt;simplifyEnrichment&lt;/strong&gt;. Let&amp;rsquo;s say, you have&#xA;a list of genomic regions of interest (in the following example, we use a list of transcription factor&#xA;binding sites). You do a GO enrichment analysis with &lt;strong&gt;rGREAT&lt;/strong&gt; and visualize the enrichment results&#xA;with &lt;strong&gt;simplifyEnrichment&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rGREAT)&#xA;df = read.table(url(&amp;quot;https://raw.githubusercontent.com/jokergoo/rGREAT_suppl/master/data/tb_encTfChipPkENCFF708LCH_A549_JUN_hg19.bed&amp;quot;))&#xA;# convert to a GRanges object&#xA;gr = GRanges(seqnames = df[, 1], ranges = IRanges(df[, 2], df[, 3]))&#xA;res = great(gr, &amp;quot;BP&amp;quot;, &amp;quot;hg19&amp;quot;)&#xA;tb = getEnrichmentTable(res)&#xA;head(tb)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;##           id                         description genome_fraction observed_region_hits&#xA;## 1 GO:0042981     regulation of apoptotic process       0.1420187                  386&#xA;## 2 GO:0043067 regulation of programmed cell death       0.1460764                  390&#xA;## 3 GO:0006915                   apoptotic process       0.1812937                  472&#xA;## 4 GO:0012501               programmed cell death       0.1860361                  481&#xA;## 5 GO:0033554         cellular response to stress       0.1564119                  404&#xA;## 6 GO:0008219                          cell death       0.1862993                  481&#xA;##   fold_enrichment p_value p_adjust mean_tss_dist observed_gene_hits gene_set_size&#xA;## 1        1.574712       0        0        125448                274          1427&#xA;## 2        1.546834       0        0        126430                279          1469&#xA;## 3        1.508407       0        0        124425                339          1883&#xA;## 4        1.497984       0        0        124981                349          1944&#xA;## 5        1.496479       0        0        134999                293          1812&#xA;## 6        1.495868       0        0        125470                350          1948&#xA;##   fold_enrichment_hyper p_value_hyper p_adjust_hyper&#xA;## 1              1.571393  2.220446e-15   5.315748e-13&#xA;## 2              1.554321  4.662937e-15   1.014825e-12&#xA;## 3              1.473356  9.769963e-15   1.913669e-12&#xA;## 4              1.469222  5.440093e-15   1.132485e-12&#xA;## 5              1.323329  1.098226e-07   3.529066e-06&#xA;## 6              1.470406  4.329870e-15   9.872103e-13&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(simplifyEnrichment)&#xA;sig_go_ids = tb$id[tb$p_adjust &amp;lt; 0.001]&#xA;cl = simplifyGO(sig_go_ids)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2024-02-05-get-gene-region-associations-for-a-group-of-go-terms_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;864&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(cl)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;##           id cluster&#xA;## 1 GO:0042981       1&#xA;## 2 GO:0043067       1&#xA;## 3 GO:0006915       1&#xA;## 4 GO:0012501       1&#xA;## 5 GO:0033554       2&#xA;## 6 GO:0008219       1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;table(cl$cluster)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## &#xA;##   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22 &#xA;##  14 146 169   1   1  28  85  28  10  44  17  13   1   1  11   8   3   1   1   3   3   3&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The plot looks not bad. Next you may want to get the gene-region associations for significant GO terms.&#xA;For example, the association for the first GO term:&lt;/p&gt;</description>
    </item>
    <item>
      <title>R session 中软件包依赖关系网络</title>
      <link>/lab-cn/2023/11/16/package-dependencies-in-your-session/</link>
      <pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/11/16/package-dependencies-in-your-session/</guid>
      <description>&lt;link href=&#34;/lab-cn/rmarkdown-libs/htmltools-fill/fill.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/htmltools-fill/fill.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/htmltools-fill/fill.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/htmltools-fill/fill.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/htmltools-fill/fill.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/htmltools-fill/fill.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/viz/viz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;/lab-cn/rmarkdown-libs/DiagrammeR-styles/styles.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;/lab-cn/rmarkdown-libs/grViz-binding/grViz.js&#34;&gt;&lt;/script&gt;&#xA;&lt;p&gt;在R markdown文档中将&lt;code&gt;sessionInfo()&lt;/code&gt;放在末尾几乎已经成为一种标准。&lt;code&gt;sessionInfo()&lt;/code&gt;能够打印出加载到R session中的包的列表。但这些包之间的依赖关系又如何呢？在这篇博文中，让我们来看看。&lt;/p&gt;&#xA;&lt;p&gt;让我们打开一个新的R session并仅加载&lt;strong&gt;ggplot2&lt;/strong&gt;包：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;接下来我们运行&lt;code&gt;sessionInfo()&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x1 = sessionInfo()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;打印&lt;code&gt;x1&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## R version 4.3.1 (2023-06-16)&#xA;## Platform: x86_64-apple-darwin20 (64-bit)&#xA;## Running under: macOS Ventura 13.2.1&#xA;## &#xA;## Matrix products: default&#xA;## BLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib &#xA;## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0&#xA;## &#xA;## locale:&#xA;## [1] C/UTF-8/C/C/C/C&#xA;## &#xA;## time zone: Europe/Berlin&#xA;## tzcode source: internal&#xA;## &#xA;## attached base packages:&#xA;## [1] stats     graphics  grDevices utils     datasets  methods   base     &#xA;## &#xA;## other attached packages:&#xA;## [1] ggplot2_3.4.4&#xA;## &#xA;## loaded via a namespace (and not attached):&#xA;##  [1] utf8_1.2.3       R6_2.5.1         tidyselect_1.2.0 magrittr_2.0.3   gtable_0.3.4    &#xA;##  [6] glue_1.6.2       tibble_3.2.1     pkgconfig_2.0.3  generics_0.1.3   dplyr_1.1.3     &#xA;## [11] lifecycle_1.0.3  cli_3.6.1        fansi_1.0.5      scales_1.2.1     grid_4.3.1      &#xA;## [16] vctrs_0.6.4      withr_2.5.1      compiler_4.3.1   munsell_0.5.0    pillar_1.9.0    &#xA;## [21] colorspace_2.1-0 rlang_1.1.1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;只有二十几个包被载入，看起来不是很多。返回变量&lt;code&gt;x1&lt;/code&gt;是一个列表，其中包含了直接或间接加载的包列表。这些包可以分为三组：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Simplified simplifyEnrichment plot</title>
      <link>/lab-cn/2023/10/02/simplified-simplifyenrichment-plot/</link>
      <pubDate>Mon, 02 Oct 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/10/02/simplified-simplifyenrichment-plot/</guid>
      <description>&lt;p&gt;The &lt;code&gt;lt&lt;/code&gt; object contains a list of GO enrichment tables.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;names(lt)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;BP_km1&amp;quot; &amp;quot;BP_km2&amp;quot; &amp;quot;BP_km3&amp;quot; &amp;quot;BP_km4&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(lt[[1]][, 1:7])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;##                    ID                         Description GeneRatio   BgRatio RichFactor&#xA;## GO:0006974 GO:0006974                 DNA damage response    84/471 924/18986 0.09090909&#xA;## GO:0006281 GO:0006281                          DNA repair    65/471 625/18986 0.10400000&#xA;## GO:1903047 GO:1903047          mitotic cell cycle process    71/471 784/18986 0.09056122&#xA;## GO:0000278 GO:0000278                  mitotic cell cycle    76/471 929/18986 0.08180840&#xA;## GO:0051052 GO:0051052 regulation of DNA metabolic process    52/471 505/18986 0.10297030&#xA;## GO:0051276 GO:0051276             chromosome organization    58/471 644/18986 0.09006211&#xA;##            FoldEnrichment   zScore&#xA;## GO:0006974       3.664544 13.24432&#xA;## GO:0006281       4.192238 12.94318&#xA;## GO:1903047       3.650521 12.08881&#xA;## GO:0000278       3.297695 11.45332&#xA;## GO:0051052       4.150730 11.44585&#xA;## GO:0051276       3.630402 10.83167&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We first demonstrate the new plot on the single enrichment table. To use the &lt;strong&gt;simplifyEnrichment&lt;/strong&gt; package,&#xA;we extract significant GO terms, and then call &lt;code&gt;simplifyGO()&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dynamic graphical object in grid, part 2</title>
      <link>/lab-cn/2023/09/25/dynamic-graphical-object-in-grid-part-2/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/09/25/dynamic-graphical-object-in-grid-part-2/</guid>
      <description>&lt;p&gt;I have introduced how to define a dynamic grob by setting its &lt;code&gt;makeContext()&lt;/code&gt; method. In this post,&#xA;I will demonstrate two other ways, which are either identical to the previous method, or very similar to it.&lt;/p&gt;&#xA;&lt;p&gt;Again, the plotting task: drawing two circles at &lt;code&gt;(1, 0)&lt;/code&gt; and &lt;code&gt;(-1, 0)&lt;/code&gt; with both radius of 1, and&#xA;we want the two circles fill the plotting region as much as possible no matter how the graphical device is resized.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dynamic graphical object in grid, part 1</title>
      <link>/lab-cn/2023/09/22/dynamic-graphical-object-in-grid-part-1/</link>
      <pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/09/22/dynamic-graphical-object-in-grid-part-1/</guid>
      <description>&lt;p&gt;Consider the following task: drawing two circles at &lt;code&gt;(1, 0)&lt;/code&gt; and &lt;code&gt;(-1, 0)&lt;/code&gt; with both radius of 1.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;theta = seq(0, 2*pi, length = 50)&#xA;&#xA;x1 = cos(theta) + 1&#xA;y1 = sin(theta)&#xA;&#xA;x2 = cos(theta) - 1&#xA;y2 = sin(theta)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We might think of the following way:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(grid)&#xA;grid.newpage()&#xA;pushViewport(viewport(xscale = c(-2, 2), yscale = c(-1, 1)))&#xA;grid.lines(x1, y1, default.units = &amp;quot;native&amp;quot;)&#xA;grid.lines(x2, y2, default.units = &amp;quot;native&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2023-09-22-dynamic-graphical-object-in-grid-part-1_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;Unfortunately it only works when the width of the image is twice of the height.&lt;/p&gt;</description>
    </item>
    <item>
      <title>学术期刊 top 作者</title>
      <link>/lab-cn/2023/07/25/journals-top-authors/</link>
      <pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/07/25/journals-top-authors/</guid>
      <description>&lt;p&gt;NCBI 提供的 &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/books/NBK25501/&#34;&gt;E-utilities&lt;/a&gt; API 可以很方便的从 NCBI 的数据库中提取信息。对于其 PubMed 数据库，&#xA;&lt;strong&gt;pubmedR&lt;/strong&gt; 封装了 E-utilities API（内部基于底层 &lt;strong&gt;rentrez&lt;/strong&gt; 包），用户可以更为直接的从 PubMed 数据库提取相应的数据。&lt;/p&gt;&#xA;&lt;p&gt;本文将展示如何获取来自某一学术期刊的所有论文，通过分析作者，获取在此学术期刊上发表论文最高的作者。&lt;/p&gt;&#xA;&lt;p&gt;批量从 PubMed 上获取数据需要提供 NCBI 的 API key。可以免费获得，具体步骤为：登录 NCBI -&amp;gt; Account Settings -&amp;gt; API Key Management。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(pubmedR)&#xA;api_key = &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;对 PubMed 数据库进行查询时，我们需要提供格式化的查询字串，详见 &lt;a href=&#34;https://pubmed.ncbi.nlm.nih.gov/help/#using-search-field-tags&#34;&gt;https://pubmed.ncbi.nlm.nih.gov/help/#using-search-field-tags&lt;/a&gt; 。如果不知道如何编写查询字串，可先在网页版上输入查询内容，PubMed 的搜索功能会自动将其格式化成标准查询字串，然后再&#xA;按照自己的需求略加修改即可。&lt;/p&gt;&#xA;&lt;p&gt;注意通过 NCBI&#xA;API 最多一次只能获取一万条记录，如果超过一万条，需要分次获取。在下面的例子中，我们将所有2014年至2025年 Bioinformatics 期刊上的所有论文分两次获取。&lt;/p&gt;&#xA;&lt;p&gt;期刊的标准名字可以在 &lt;a href=&#34;https://ftp.ncbi.nlm.nih.gov/pubmed/J_Medline.txt&#34;&gt;https://ftp.ncbi.nlm.nih.gov/pubmed/J_Medline.txt&lt;/a&gt; 查询获得。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;query = &#39;(&amp;quot;Bioinformatics (Oxford, England)&amp;quot;[Journal]) AND ((&amp;quot;1998&amp;quot;[Date - Publication] : &amp;quot;2014&amp;quot;[Date - Publication]))&#39;&#xA;res = pmQueryTotalCount(query = query, api_key = api_key)&#xA;D1 = pmApiRequest(query = query, limit = res$total_count, api_key = NULL)&#xA;&#xA;query = &#39;(&amp;quot;Bioinformatics (Oxford, England)&amp;quot;[Journal]) AND ((&amp;quot;2015&amp;quot;[Date - Publication] : &amp;quot;2025&amp;quot;[Date - Publication]))&#39;&#xA;res = pmQueryTotalCount(query = query, api_key = api_key)&#xA;D2 = pmApiRequest(query = query, limit = res$total_count, api_key = NULL)&#xA;&#xA;D1 = pmApi2df(D1)&#xA;D2 = pmApi2df(D2)&#xA;df = rbind(D1, D2)&#xA;&#xA;df = df[df$DT == &amp;quot;JOURNAL ARTICLE&amp;quot;, ]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;现在所有的论文信息均存储在&lt;code&gt;df&lt;/code&gt;数据框中，其中作者列表在&lt;code&gt;AF&lt;/code&gt;列中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>hclust 对象里究竟有什么？</title>
      <link>/lab-cn/2023/07/07/what-is-a-hclust-object/</link>
      <pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/07/07/what-is-a-hclust-object/</guid>
      <description>&lt;p&gt;等级聚类或者层级聚类是常用的数据分析方法，在R中，我们使用&lt;code&gt;hclust()&lt;/code&gt;函数进行聚类分析。&lt;code&gt;hclust()&lt;/code&gt;返回一个&lt;code&gt;hclust&lt;/code&gt;类的对象。在本文中，让我们来揭开&lt;code&gt;hclust&lt;/code&gt;对象的真面目。&lt;/p&gt;&#xA;&lt;p&gt;首先生成一个随机的5x5矩阵，我们对矩阵的行进行聚类。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(123456)&#xA;m = matrix(rnorm(25), 5)&#xA;rownames(m) = letters[1:5]&#xA;hc = hclust(dist(m))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;hc&lt;/code&gt;属于一个&lt;code&gt;hclust&lt;/code&gt;的类。输入&lt;code&gt;hc&lt;/code&gt;变量名打印出这个变量的一些基本信息。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;hc&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## &#xA;## Call:&#xA;## hclust(d = dist(m))&#xA;## &#xA;## Cluster method   : complete &#xA;## Distance         : euclidean &#xA;## Number of objects: 5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;基本上就告诉你这是一个黑盒子，不告诉你其内部的结构。使用&lt;code&gt;plot()&lt;/code&gt;函数可以绘制聚类图。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot(hc)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2023-07-07-what-is-a-hclust-object_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;480&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;上面这两步是最标准的进行等级聚类分析的步骤，那么，&lt;code&gt;hc&lt;/code&gt;变量中到底存储着什么信息呢？&#xA;本文就来揭示这个&lt;code&gt;hc&lt;/code&gt;变量的内部结构。在遇到任何一个未知格式的对象时，一般我们使用&lt;code&gt;str()&lt;/code&gt;来展示其内部结构：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;str(hc)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## List of 7&#xA;##  $ merge      : int [1:4, 1:2] -3 -1 1 -5 -4 -2 2 3&#xA;##  $ height     : num [1:4] 2.01 2.48 3.51 4.11&#xA;##  $ order      : int [1:5] 5 3 4 1 2&#xA;##  $ labels     : chr [1:5] &amp;quot;a&amp;quot; &amp;quot;b&amp;quot; &amp;quot;c&amp;quot; &amp;quot;d&amp;quot; ...&#xA;##  $ method     : chr &amp;quot;complete&amp;quot;&#xA;##  $ call       : language hclust(d = dist(m))&#xA;##  $ dist.method: chr &amp;quot;euclidean&amp;quot;&#xA;##  - attr(*, &amp;quot;class&amp;quot;)= chr &amp;quot;hclust&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;可以看到，&lt;code&gt;hc&lt;/code&gt;只是一个包含7个成员的简单列表。最后三个成员&lt;code&gt;method&lt;/code&gt;，&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;dist.method&lt;/code&gt;只是关于此变量的一些文字标记，我们跳过不谈。我们主要看前四个成员。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Align heatmaps</title>
      <link>/lab-cn/2023/04/03/align-heatmaps/</link>
      <pubDate>Mon, 03 Apr 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/04/03/align-heatmaps/</guid>
      <description>&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; can make a list of heatmap where rows or columns in different heatmaps can be easily&#xA;corresponded. However, in some scenarios, users may only want to combine multiple plots into one single and large plot,&#xA;where each plot is like a figure panel. Normally we use &lt;strong&gt;cowplot&lt;/strong&gt; or &lt;strong&gt;patchwork&lt;/strong&gt; package, or even manually with&#xA;&lt;code&gt;pushViewport()&lt;/code&gt;/&lt;code&gt;viewport()&lt;/code&gt; functions to combine multiple figure panels, but for heatmaps, users may additionally&#xA;want all heatmaps are aligned by the heatmap bodies, while not by the whole heatmap plot.&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 Hilbert 曲线可视化 CPAN 上 Perl 模块分布</title>
      <link>/lab-cn/2023/01/09/visualize-cpan-modules-with-hilbert-curve/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2023/01/09/visualize-cpan-modules-with-hilbert-curve/</guid>
      <description>&lt;p&gt;在网站 &lt;a href=&#34;http://mapofcpan.org/&#34;&gt;http://mapofcpan.org/&lt;/a&gt; 上有一个非常好看的对CPAN Perl模块可视化的例子，如下图：&lt;/p&gt;&#xA;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/8yoFdJolUibdJN06UTIicSaVyvzkzZOmaSBs7YkJzBQ1g3p2P6eHYKeic2oQT48hDJwAVqhnwhl0r3jCoavUNzb7A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1#imgIndex=0&#34; /&gt;&#xA;&lt;p&gt;在这篇文章中，我将展示如何使用R包&lt;strong&gt;HilbertCurve&lt;/strong&gt;来绘制这样的图。&lt;/p&gt;&#xA;&lt;p&gt;我们首先读入CPAN上所有模块的名字，这个可以在 &lt;a href=&#34;https://www.cpan.org/modules/02packages.details.txt&#34;&gt;https://www.cpan.org/modules/02packages.details.txt&lt;/a&gt; 中找到。下面我们直接将这个文件读入：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df = read.table(&amp;quot;https://www.cpan.org/modules/02packages.details.txt&amp;quot;, skip = 9)&#xA;head(df)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;##                     V1    V2                                            V3&#xA;## 1            A1z::Html  0.04              C/CE/CEEJAY/A1z-Html-0.04.tar.gz&#xA;## 2 A1z::HTML5::Template  0.22    C/CE/CEEJAY/A1z-HTML5-Template-0.22.tar.gz&#xA;## 3      A_Third_Package undef           C/CL/CLEMBURG/Test-Unit-0.13.tar.gz&#xA;## 4            AAA::Demo undef      J/JW/JWACH/Apache-FastForward-1.1.tar.gz&#xA;## 5            AAA::eBay undef      J/JW/JWACH/Apache-FastForward-1.1.tar.gz&#xA;## 6                 AAAA undef P/PR/PRBRENAN/Data-Table-Text-20210818.tar.gz&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;模块的名字在第一列中，我们首先将其排序。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;all_modules = sort(df[, 1])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们取每个模块的“命名空间”。命名空间是第一个&lt;code&gt;::&lt;/code&gt;前面的字符串。注意，在Perl中，这可能不叫做命名空间，在这篇文章，为方便起见，我们称之为命名空间。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ns = gsub(&amp;quot;::.*$&amp;quot;, &amp;quot;&amp;quot;, all_modules)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;现在&lt;code&gt;ns&lt;/code&gt;是一个字符串向量，下面我们将其中的每一个值对应到一条Hilbert曲线上。我们首次将其转换为一个&lt;code&gt;Rle&lt;/code&gt;对象。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(IRanges)&#xA;r = Rle(ns)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;Rle&lt;/code&gt;是一个很简单的类，定义在&lt;strong&gt;IRanges&lt;/strong&gt;包中。在变量&lt;code&gt;r&lt;/code&gt;中，每一个元素对应着&lt;code&gt;ns&lt;/code&gt;中一个单独的命名空间，在向量&lt;code&gt;ns&lt;/code&gt;中，每一个命名空间的位置和长度也被计算出。在下面的代码中，我们提取出这些信息：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Draw links on the two different sides of a track</title>
      <link>/lab-cn/2022/12/09/draw-links-on-the-two-different-sides-of-a-track/</link>
      <pubDate>Fri, 09 Dec 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/12/09/draw-links-on-the-two-different-sides-of-a-track/</guid>
      <description>&lt;p&gt;Links in circos plot can show relations between elements. In most cases, links&#xA;are drawn in the most inside of the circle. However, separating links into two&#xA;categories of those having short distances and those having large distances, and&#xA;distinguishing them by putting them onto different sides of a track can sometimes&#xA;improve the visualization. One typical example is to separate intergenic&#xA;translocations and intragenic translocations of genes.&lt;/p&gt;&#xA;&lt;p&gt;In the next example, I first generate positions for three genes (&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;).&#xA;Note for simplicity, the positions are not really bases.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Partially change default values of arguments</title>
      <link>/lab-cn/2022/10/22/partially-change-default-values-of-arguments/</link>
      <pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/10/22/partially-change-default-values-of-arguments/</guid>
      <description>&lt;p&gt;This is the problem I have. For example, in the &lt;code&gt;Heatmap()&lt;/code&gt; function in the &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package, one of its argument &lt;code&gt;row_title_gp&lt;/code&gt; has a default value &lt;code&gt;gpar(fontsize = 13.2)&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;Heatmap = function(..., row_title_gp = gpar(fontsize = 13.2), ...) {&#xA;    ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Here &lt;code&gt;row_title_gp&lt;/code&gt; controls the graphics parameters for the row title and it accepts a list of other parameters, such as &lt;code&gt;col&lt;/code&gt; and &lt;code&gt;fontfamily&lt;/code&gt;.&#xA;Now the problem is when users set &lt;code&gt;row_title_gp&lt;/code&gt; with other parameters, e.g. to set the color of text, they must also set &lt;code&gt;fontsize&lt;/code&gt; with its default value,&#xA;even though when they only want to set the color. If they do not set &lt;code&gt;fontsize&lt;/code&gt;, it will not use the default value of 13.2, while it will use the &amp;ldquo;global default&amp;rdquo; which is 12 (try &lt;code&gt;get.gpar(&amp;quot;fontsize&amp;quot;)&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Visualize lift over between two assemblies</title>
      <link>/lab-cn/2022/09/13/visualize-lift-over-between-two-assemblies/</link>
      <pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/09/13/visualize-lift-over-between-two-assemblies/</guid>
      <description>&lt;p&gt;In this post, I will simply demonstrate how to visualize lift overs between two assemblies.&#xA;In the package &lt;strong&gt;rtracklayer&lt;/strong&gt;, there is a function &lt;code&gt;liftOver()&lt;/code&gt; that can convert genomic regions&#xA;according to the mapping encoded in a &amp;ldquo;chain&amp;rdquo; file.&lt;/p&gt;&#xA;&lt;p&gt;In the following code, I will demonstrate the lift overs from hg19 to hg38. I first download&#xA;the chain file from UCSC database. Note the &lt;code&gt;.gz&lt;/code&gt; file needs to be uncompressed.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(glue)&#xA;chain_file = &amp;quot;https://hgdownload.soe.ucsc.edu/gbdb/hg19/liftOver/hg19ToHg38.over.chain.gz&amp;quot;&#xA;chain_file_basename = basename(chain_file)&#xA;tmp_dir = tempdir()&#xA;local_file = glue(&amp;quot;{tmp_dir}/{chain_file_basename}&amp;quot;)&#xA;download.file(chain_file, destfile = local_file)&#xA;system(glue(&amp;quot;gzip -d -f &#39;{local_file}&#39;&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Simply use &lt;code&gt;import.chain()&lt;/code&gt; to create a &lt;code&gt;Chain&lt;/code&gt; object.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Textbox annotation</title>
      <link>/lab-cn/2022/06/15/textbox-annotation/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/06/15/textbox-annotation/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://jokergoo.github.io/2020/05/31/word-cloud-as-heatmap-annotation/&#34;&gt;a previous post &amp;ldquo;Word cloud as heatmap&#xA;annotation&amp;rdquo;&lt;/a&gt;,&#xA;I introduced how to make word clouds and attach them to heatmaps as&#xA;annotations. Here I will introduce a more general solution for making&#xA;textboxes.&lt;/p&gt;&#xA;&lt;p&gt;The following new functions are implemented in &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; from version&#xA;2.13.1. Now you need to update &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; from GitHub.&lt;/p&gt;&#xA;&lt;p&gt;First I will demonstrate a low-level &lt;code&gt;grid.*&lt;/code&gt; family function&#xA;&lt;code&gt;grid.textbox()&lt;/code&gt;. The function simply accepts a vector of texts. If the &lt;code&gt;col&lt;/code&gt;&#xA;parameter is not specified in &lt;code&gt;gpar()&lt;/code&gt;, random colors are used.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How to change font family globally in ComplexHeatmap</title>
      <link>/lab-cn/2022/05/31/how-to-change-font-family-globally-in-complexheatmap/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/05/31/how-to-change-font-family-globally-in-complexheatmap/</guid>
      <description>&lt;p&gt;In &lt;strong&gt;grid&lt;/strong&gt;, every viewport is associated with its own graphics parameters and it by default inherits graphics parameters from&#xA;its parent viewport. So, to globally change the font family in a ComplexHeatmap plot, we can simply put the heatmap into&#xA;a &amp;ldquo;global viewport&amp;rdquo; where we can set a specific font family (also other graphics parameters) there:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;m = matrix(rnorm(100), 10)&#xA;&#xA;pushViewport(viewport(gp = gpar(fontfamily = &amp;quot;HersheyScript&amp;quot;)))&#xA;ht = Heatmap(m, top_annotation = HeatmapAnnotation(foo = 1:10),&#xA;    right_annotation = rowAnnotation(bar = anno_text(month.name[1:10])),&#xA;    column_title = &amp;quot;A small matrix&amp;quot;)&#xA;draw(ht, newpage = FALSE)&#xA;popViewport()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2022-05-31-how-to-change-font-family-globally_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;Note in &lt;code&gt;draw()&lt;/code&gt;, setting &lt;code&gt;newpage = FALSE&lt;/code&gt; is important.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set cell_fun/layer_fun in InteractiveComplexHeatmap</title>
      <link>/lab-cn/2022/04/01/set-cell_fun/layer_fun-in-interactivecomplexheatmap/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/04/01/set-cell_fun/layer_fun-in-interactivecomplexheatmap/</guid>
      <description>&lt;p&gt;In the interactive heatmap produced by &lt;strong&gt;InteractiveComplexHeatmap&lt;/strong&gt; package,&#xA;the sub-heatmap is just a zooming of the main heatmap, which means, if&#xA;&lt;code&gt;cell_fun&lt;/code&gt; or &lt;code&gt;layer_fun&lt;/code&gt; is set in &lt;code&gt;Heatmap()&lt;/code&gt;, both main heatmap and&#xA;sub-heatmap will execute it. &lt;code&gt;cell_fun&lt;/code&gt; and &lt;code&gt;layer_fun&lt;/code&gt; provides a way to&#xA;customize the heatmap cells, but when the main heatmap is huge, adding more&#xA;graphics via &lt;code&gt;cell_fun&lt;/code&gt;/&lt;code&gt;layer_fun&lt;/code&gt; apparently is not a good idea. Users may&#xA;want to suppress &lt;code&gt;cell_fun&lt;/code&gt;/&lt;code&gt;layer_fun&lt;/code&gt; (or just draw very simple graphics&#xA;which will not disturb the reading of the heatmap) in the main heatmap, while only to execute them in&#xA;the sub-heatmap.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Support HCL colormaps in ComplexHeatmap</title>
      <link>/lab-cn/2022/03/08/support-hcl-colormaps-in-complexheatmap/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/03/08/support-hcl-colormaps-in-complexheatmap/</guid>
      <description>&lt;p&gt;To demonstrate this new feature, I first generate a small random matrix.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(123)&#xA;nr1 = 4; nr2 = 8; nr3 = 6; nr = nr1 + nr2 + nr3&#xA;nc1 = 6; nc2 = 8; nc3 = 10; nc = nc1 + nc2 + nc3&#xA;mat = cbind(rbind(matrix(rnorm(nr1*nc1, mean = 1,   sd = 0.5), nr = nr1),&#xA;                  matrix(rnorm(nr2*nc1, mean = 0,   sd = 0.5), nr = nr2),&#xA;                  matrix(rnorm(nr3*nc1, mean = 0,   sd = 0.5), nr = nr3)),&#xA;            rbind(matrix(rnorm(nr1*nc2, mean = 0,   sd = 0.5), nr = nr1),&#xA;                  matrix(rnorm(nr2*nc2, mean = 1,   sd = 0.5), nr = nr2),&#xA;                  matrix(rnorm(nr3*nc2, mean = 0,   sd = 0.5), nr = nr3)),&#xA;            rbind(matrix(rnorm(nr1*nc3, mean = 0.5, sd = 0.5), nr = nr1),&#xA;                  matrix(rnorm(nr2*nc3, mean = 0.5, sd = 0.5), nr = nr2),&#xA;                  matrix(rnorm(nr3*nc3, mean = 1,   sd = 0.5), nr = nr3))&#xA;           )&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Since this matrix contains both positive and negative values, we may want the color mapping to be symmetric to zero,&#xA;thus we define a zero-centric color mapping function with &lt;code&gt;circlize::colorRamp2()&lt;/code&gt;.&#xA;The &amp;ldquo;blue-white-red&amp;rdquo; heatmap looks like as follows:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Easily convert static heatmaps to interactive heatmaps in Shiny apps</title>
      <link>/lab-cn/2022/03/01/easily-convert-static-heatmaps-to-interactive-heatmaps-in-shiny-apps/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2022/03/01/easily-convert-static-heatmaps-to-interactive-heatmaps-in-shiny-apps/</guid>
      <description>&lt;p&gt;Some people might have already implemented &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; in their Shiny&#xA;apps, where a static heatmap is automatically generated by adjusting&#xA;parameters for heatmaps. For example, in the following example, in the left panel,&#xA;users can control three types of parameters for heatmaps:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Whether to apply clustering?&lt;/li&gt;&#xA;&lt;li&gt;Whether to order heatmaps by row and column names?&lt;/li&gt;&#xA;&lt;li&gt;Whether to perform k-means clustering with 2-group on both rows and columns?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The following code can be directly copied and pasted to an R session. It is runnable.&lt;/p&gt;</description>
    </item>
    <item>
      <title>A completely customized annotation</title>
      <link>/lab-cn/2021/10/17/a-completely-customized-annotation/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/10/17/a-completely-customized-annotation/</guid>
      <description>&lt;p&gt;For most annotation functions implemented in &lt;strong&gt;ComplexHeatmap&lt;/strong&gt;, they only draw one same type of annotation graphics, e.g. &lt;code&gt;anno_points()&lt;/code&gt;&#xA;only draws points. From &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; version 2.9.4, I added a new annotation function &lt;code&gt;anno_customize()&lt;/code&gt;, with which you can completely&#xA;freely define graphics for every annotation cell.&lt;/p&gt;&#xA;&lt;p&gt;The input for &lt;code&gt;anno_customize()&lt;/code&gt; should be a categorical vector.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;x = c(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;d&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For each level, you need to define a graphics function for it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Visualize the &#39;real&#39; circular genome</title>
      <link>/lab-cn/2021/09/18/visualize-the-real-circular-genome/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/09/18/visualize-the-real-circular-genome/</guid>
      <description>&lt;p&gt;&lt;strong&gt;circlize&lt;/strong&gt; applies circular visualization. Essentially, it visualizes data in categories. E.g. for genomic data,&#xA;the circle is segmented and each segment (or called sector) corresponds to one single chromosome. The following code visualizes 24 chromosomes of human genome.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;circos.initializeWithIdeogram()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2021-09-18-visualize-the-real-circular-genome_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;768&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;Now the question is how to visualize a &amp;ldquo;real&amp;rdquo; circular genome where the complete circle corresponds to the genome and the &amp;ldquo;end&amp;rdquo; of the genome&#xA;goes smoothly over the &amp;ldquo;start&amp;rdquo; of the genome.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Create self-defined annotations</title>
      <link>/lab-cn/2021/08/04/create-self-defined-annotations/</link>
      <pubDate>Wed, 04 Aug 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/08/04/create-self-defined-annotations/</guid>
      <description>&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; already provides many annotation functions that draw various types of graphics, but still, users might want&#xA;more new types. Here I demonstrate how to create new annotation graphics.&lt;/p&gt;&#xA;&lt;p&gt;In the &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; book (&lt;a href=&#34;https://jokergoo.github.io/ComplexHeatmap-reference/book/heatmap-annotations.html#implement-new-annotation-functions)&#34;&gt;https://jokergoo.github.io/ComplexHeatmap-reference/book/heatmap-annotations.html#implement-new-annotation-functions)&lt;/a&gt;,&#xA;I have already explained how to create new annotations with the function &lt;code&gt;AnnotationFunction()&lt;/code&gt;. Here I demonstrate a simplified way&#xA;to construct a new annotation type which also allows reordering, subsetting and splitting.&lt;/p&gt;&#xA;&lt;p&gt;From version 2.9.3, &lt;code&gt;AnnotationFunction()&lt;/code&gt; allows a new argument &lt;code&gt;cell_fun&lt;/code&gt; which draws graphics in every single &amp;ldquo;annotation cell&amp;rdquo;. The value&#xA;for &lt;code&gt;cell_fun&lt;/code&gt; is a self-defind graphics function and the only argument is the &amp;ldquo;current index&amp;rdquo; of the corresponding heatmap rows or columns.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Make triangle heatmap</title>
      <link>/lab-cn/2021/07/22/make-triangle-heatmap/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/07/22/make-triangle-heatmap/</guid>
      <description>&lt;p&gt;For the following heatmap symmetric to the diagonal, users might only want to draw the lower or upper triangle heatmap.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;m = cor(matrix(rnorm(100), 10))&#xA;Heatmap(m)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2021-07-22-make-triangle-heatmap_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;576&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;By observing the heatmap, the simplest way is to compare the row index and column index of the heatmap. Note&#xA;here since the heatmap rows and columns are already reordered by clusering, we need to reorder the matrix&#xA;before sending to heatmap, and in the heatmap, no reordering should be applied.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multiple color themes in a single heatmap</title>
      <link>/lab-cn/2021/05/11/multiple-color-themes-in-a-single-heatmap/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/05/11/multiple-color-themes-in-a-single-heatmap/</guid>
      <description>&lt;p&gt;Some people might want to use multiple color schemas in a single heatmap to&#xA;highlight group-wise patterns. If groups are also separated in heatmap, then actually&#xA;each group can be treated as a single heatmap with its own color theme,&#xA;later these heatmaps can be concatenated into the final heatmap.&lt;/p&gt;&#xA;&lt;p&gt;In the following example, we assume there are two groups on columns. Colors for group A use&#xA;the theme &amp;ldquo;green-black-red&amp;rdquo; and colors for group B use &amp;ldquo;purple-white-orange&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Implement interactive heatmap from scratch</title>
      <link>/lab-cn/2021/04/05/implement-interactive-heatmap-from-scratch/</link>
      <pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/04/05/implement-interactive-heatmap-from-scratch/</guid>
      <description>&lt;p&gt;In &lt;strong&gt;InteractiveComplexHeatmap&lt;/strong&gt;, we mainly use the combination of&#xA;&lt;code&gt;InteractiveComplexHeatmapOutput()&lt;/code&gt; and &lt;code&gt;makeInteractiveComplexHeatmap()&lt;/code&gt; to&#xA;create the interactive heatmap widget in the Shiny application. The&#xA;interactive widgets contains many tools for manipulating heatmaps. However,&#xA;sometimes users may want to build their own interactive heatmap widget, e.g. to define their&#xA;own logic to respond to the clicking or brushing event on heatmaps, while not&#xA;use the one provided by &lt;strong&gt;InteractiveComplexHeatmap&lt;/strong&gt;. What they only want&#xA;is the information of the heatmap cells that were selected from heatmaps.&lt;/p&gt;</description>
    </item>
    <item>
      <title>3D Heatmap</title>
      <link>/lab-cn/2021/03/24/3d-heatmap/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/03/24/3d-heatmap/</guid>
      <description>&lt;div style=&#34;width:80%;border:1px dotted #EEEEEE;padding:6px 10px 0px 10px;background-color:#F8F8F8;margin:0 auto;&#34;&gt;&#xA;&lt;p style=&#34;text-align:center;&#34;&gt;From version 2.7.9, &lt;b&gt;ComplexHeatmap&lt;/b&gt; can make simple 3D heatmap with a new function &lt;code&gt;Heatmap3D()&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;h3 id=&#34;motivation&#34;&gt;Motivation&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; has a &lt;code&gt;densityHeatmap()&lt;/code&gt; to visualize a list of density&#xA;distributions, such as in the following example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;set.seed(123)&#xA;mat = matrix(rnorm(500), ncol = 10)&#xA;colnames(mat) = letters[1:10]&#xA;densityHeatmap(mat)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2021-03-21-3d-heatmap_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;384&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;In basic R graphics, since distributions can also be visualized by histograms, from &lt;strong&gt;ComplexHeatmap&lt;/strong&gt;&#xA;version 2.7.9, I added a new function &lt;code&gt;frequencyHeatmap()&lt;/code&gt; which is like a histogram-version&#xA;of density heatmap. The usage is similar as &lt;code&gt;densityHeatmap()&lt;/code&gt;:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Control labels in anno_block()</title>
      <link>/lab-cn/2021/03/11/control-labels-in-anno_block/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/03/11/control-labels-in-anno_block/</guid>
      <description>&lt;p&gt;In &lt;strong&gt;ComplexHeatmap&lt;/strong&gt;, &lt;code&gt;labels&lt;/code&gt; and other related settings in &lt;code&gt;anno_block()&lt;/code&gt;&#xA;always correspond to the heatmap slices from top to bottom &lt;strong&gt;after the heatmap&#xA;is generated&lt;/strong&gt;, which means, you always need to first generate the heatmap,&#xA;then to observe how the heatmap slices are ordered and finally to set a proper value for&#xA;&lt;code&gt;labels&lt;/code&gt;. It is difficult to map the labels in &lt;code&gt;anno_block()&lt;/code&gt; to the heatmap&#xA;slices if clustering is applied, or when the ordering is unknown before the heatmap&#xA;is drawn.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cluster groups in ComplexHeatmap</title>
      <link>/lab-cn/2021/03/05/cluster-groups-in-complexheatmap/</link>
      <pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/03/05/cluster-groups-in-complexheatmap/</guid>
      <description>&lt;p&gt;When making heatmaps, we always have many additionally grouping information&#xA;for the samples, sush as subtypes, phenotypes. To emphasize the difference&#xA;between groups, we might want to only perform clustering on group level, while&#xA;not on the complete dataset. For these scenarios, &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; has two&#xA;functions: &lt;code&gt;cluster_between_groups()&lt;/code&gt; and &lt;code&gt;cluster_within_group()&lt;/code&gt;. The two&#xA;functions all perform clustering on group level. The difference is, in&#xA;&lt;code&gt;cluster_between_groups()&lt;/code&gt;, inside each group, the order of samples is&#xA;unchanged, while in &lt;code&gt;cluster_within_group()&lt;/code&gt;, samples in each group are still&#xA;clustered.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Differentiate brush and hover event in Shiny</title>
      <link>/lab-cn/2021/02/21/differentiate-brush-and-hover-event-in-shiny/</link>
      <pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/02/21/differentiate-brush-and-hover-event-in-shiny/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://jokergoo.github.io/2021/02/20/differentiate-brush-and-click-event-in-shiny/&#34;&gt;In my last post&lt;/a&gt; I described how I distinguish click and brush event in &lt;code&gt;plotOutput&lt;/code&gt; in Shiny. In this post I try to solve another problem which is to differentiate hover and brush event.&lt;/p&gt;&#xA;&lt;p&gt;Similar as click, brush also intializes a hover event. To distinguish hover and brush, I didn&amp;rsquo;t use the&#xA;default hover in &lt;code&gt;plotOutput&lt;/code&gt;. Here I implement my own one. The implementation contains two parts:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;the hover event is invoked after the mouse position keeps unchanged for a peroid of time, e.g. 300ms.&lt;/li&gt;&#xA;&lt;li&gt;the brush action starts with a hover action, then instantly, a &lt;code&gt;div&lt;/code&gt; which corresponds to the brush is created.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;For part 1, we need a mouse event which stops at a certain position for a period of time. Here I use&#xA;&lt;a href=&#34;https://github.com/websanova/mousestop&#34;&gt;mousestop.js&lt;/a&gt;. And for the part 2, we just simply test whether&#xA;the brush div exists or not.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Differentiate brush and click event in Shiny</title>
      <link>/lab-cn/2021/02/20/differentiate-brush-and-click-event-in-shiny/</link>
      <pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/02/20/differentiate-brush-and-click-event-in-shiny/</guid>
      <description>&lt;p&gt;I am recently developing a package&#xA;&lt;a href=&#34;https://github.com/jokergoo/InteractiveComplexHeatmap&#34;&gt;&lt;strong&gt;InteractiveComplexHeatmap&lt;/strong&gt;&lt;/a&gt;&#xA;which generates interactive heatmaps as Shiny apps. One basic interactivity on&#xA;heatmap is to click on heatmap cells or to select a region from it. Shiny&#xA;allows to set &lt;code&gt;click&lt;/code&gt; and &lt;code&gt;brush&lt;/code&gt; arguments in &lt;code&gt;plotOutput()&lt;/code&gt; to perform&#xA;clicking or brushing on the heatmap image, and on the server side, to respond&#xA;to these two actions. In &lt;strong&gt;InteractiveComplexHeatmap&lt;/strong&gt;, I defined an action to&#xA;respond to click event and an action to respond to brush event. However, there is&#xA;one big problem that is brushing on heatmap is always intialized with a click&#xA;action, so when brushing on heatmap, both the response for click and brush&#xA;will be executed. This problem can be ignored by using &lt;code&gt;dbclick&lt;/code&gt; (double&#xA;click) instead of &lt;code&gt;click&lt;/code&gt;, but double click is not user-friendly.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set heatmap cell width in circos.heatmap function</title>
      <link>/lab-cn/2021/01/07/set-heatmap-cell-width-in-circos.heatmap-function/</link>
      <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2021/01/07/set-heatmap-cell-width-in-circos.heatmap-function/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;../../../../2020/05/21/make-circular-heatmaps/&#34;&gt;a previous&#xA;post&lt;/a&gt; I&#xA;introduced making circular heatmaps with the &lt;strong&gt;circlize&lt;/strong&gt; package. From&#xA;version 0.4.12, I add a new argument &lt;code&gt;cell_width&lt;/code&gt; in &lt;code&gt;circos.heatmap()&lt;/code&gt;&#xA;function so that the heatmap cell width is adjustable.&lt;/p&gt;&#xA;&lt;p&gt;First I generate a random dataset for making the heatmaps.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;set.seed(123)&#xA;mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), &#xA;                   matrix(rnorm(50*5, mean = -1), nr = 50)),&#xA;             cbind(matrix(rnorm(50*5, mean = -1), nr = 50), &#xA;                   matrix(rnorm(50*5, mean = 1), nr = 50))&#xA;            )&#xA;rownames(mat1) = paste0(&amp;quot;R&amp;quot;, 1:100)&#xA;colnames(mat1) = paste0(&amp;quot;C&amp;quot;, 1:10)&#xA;mat1 = mat1[sample(100, 100), ] # randomly permute rows&#xA;split = sample(letters[1:5], 100, replace = TRUE)&#xA;split = factor(split, levels = letters[1:5])&#xA;col_fun1 = colorRamp2(c(-2, 0, 2), c(&amp;quot;blue&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The value for &lt;code&gt;cell_width&lt;/code&gt; is simply a numeric vector with the same length as&#xA;the number of rows of the input matrix. The values in &lt;code&gt;cell_width&lt;/code&gt; will be&#xA;scaled in the function. In the following example, I repetitively set the&#xA;heatmap cell width with &lt;code&gt;1, 4, 1, 4, ...&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Translate from other heatmap functions to ComplexHeatmap</title>
      <link>/lab-cn/2020/12/14/translate-from-other-heatmap-functions-to-complexheatmap/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/12/14/translate-from-other-heatmap-functions-to-complexheatmap/</guid>
      <description>&lt;p&gt;In my previous post &lt;a href=&#34;../../2020/05/06/translate-from-pheatmap-to-complexheatmap/&#34;&gt;&amp;ldquo;Translate from pheatmap to&#xA;ComplexHeatmap&amp;rdquo;&lt;/a&gt;,&#xA;I introduced a &lt;code&gt;ComplexHeatmap::pheatmap()&lt;/code&gt; which smoothly executes&#xA;&lt;code&gt;pheatmap::pheatmap()&lt;/code&gt; code without any problem. With the newly developed&#xA;&lt;a href=&#34;https://github.com/jokergoo/InteractiveComplexHeatmap&#34;&gt;&lt;strong&gt;InteractiveComplexHeatmap&lt;/strong&gt;&#xA;package&lt;/a&gt;, the output of&#xA;&lt;code&gt;pheatmap()&lt;/code&gt; can be directly exported as an interactive Shiny app.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;ht = pheatmap(...)&#xA;library(InteractiveComplexHeatmap)&#xA;ht_shiny(ht)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To facilitate the users who are still using &lt;code&gt;heatmap()&lt;/code&gt; and &lt;code&gt;heatmap.2()&lt;/code&gt;&#xA;functions, to make the output of these two functions can be exported as interactive Shiny&#xA;apps as well, I implemented two similar translation functions&#xA;&lt;code&gt;ComplexHeatmap::heatmap()&lt;/code&gt; and &lt;code&gt;ComplexHeatmap::heatmap.2()&lt;/code&gt; which use the&#xA;same set of arguments as the original functions and generate almost identical&#xA;plots.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Make some fun circular plots</title>
      <link>/lab-cn/2020/11/28/make-some-fun-circular-plots/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/11/28/make-some-fun-circular-plots/</guid>
      <description>&lt;p&gt;The same set of data and plotting rules, but one is in the normal coordinate system&#xA;and the other is in the circular-transformed coordinate system.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;&#xA;par(mar = c(1, 1, 1, 1))&#xA;layout(cbind(1:2), heights = c(1, 2))&#xA;&#xA;x0 = runif(1000)&#xA;x1 = runif(1000)&#xA;&#xA;plot(NULL, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, ann = FALSE)&#xA;segments(x0, 0, x1, 1, col = rand_color(1000, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.75))&#xA;box(col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#xA;circos.initialize(c(&amp;quot;a&amp;quot;), xlim = c(0, 1))&#xA;circos.track(ylim = c(0, 1), track.height = 0.7, bg.border = NA, &#xA;&#x9;panel.fun = function(x, y) {&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[1], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[2], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#x9;&#xA;&#x9;circos.connect(x0, 0, x1, 1, &#xA;&#x9;&#x9;type = &amp;quot;normal&amp;quot;, border = NA,&#xA;&#x9;&#x9;col = rand_color(1000, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.75))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-11-28-make-some-fun-circular-plots_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;768&#34; /&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;par(mar = c(1, 1, 1, 1))&#xA;layout(cbind(1:2), heights = c(1, 2))&#xA;&#xA;x0 = runif(1000)&#xA;x1 = runif(1000)&#xA;plot(NULL, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, ann = FALSE)&#xA;&#xA;for (i in 1:1000) {&#xA;    pt = circlize:::get_bezier_points(x0[i], 0, x1[i], 1, xlim = c(0, 1), ylim = c(0, 1))&#xA;    lines(pt[, 1], pt[, 2], col = rand_color(1, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.75))&#xA;}&#xA;box(col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#xA;circos.initialize(c(&amp;quot;a&amp;quot;), xlim = c(0, 1))&#xA;circos.track(ylim = c(0, 1), track.height = 0.7, bg.border = NA, &#xA;&#x9;panel.fun = function(x, y) {&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[1], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[2], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#x9;&#xA;&#x9;circos.connect(x0, 0, x1, 1, &#xA;&#x9;&#x9;type = &amp;quot;bezier&amp;quot;, border = NA,&#xA;&#x9;&#x9;col = rand_color(1000, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.75))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-11-28-make-some-fun-circular-plots_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;768&#34; /&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;par(mar = c(1, 1, 1, 1))&#xA;layout(cbind(1:2), heights = c(1, 2))&#xA;&#xA;x0 = sort(runif(200))&#xA;x0 = matrix(x0, ncol = 2, byrow = TRUE)&#xA;x1 = sort(runif(200))&#xA;x1 = matrix(x1, ncol = 2, byrow = TRUE)&#xA;&#xA;plot(NULL, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, ann = FALSE)&#xA;&#xA;for (i in 1:100) {&#xA;    polygon(c(x0[i, 1], x0[i, 2], x1[i, 2], x1[i, 1]), c(0, 0, 1, 1), &#xA;    &#x9;col = rand_color(1, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.5),&#xA;    &#x9;border = NA)&#xA;}&#xA;box(col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#xA;circos.initialize(c(&amp;quot;a&amp;quot;), xlim = c(0, 1))&#xA;circos.track(ylim = c(0, 1), track.height = 0.7, bg.border = NA, &#xA;&#x9;panel.fun = function(x, y) {&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[1], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[2], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#xA;&#x9;circos.connect(x0, 0, x1, 1, &#xA;&#x9;&#x9;type = &amp;quot;normal&amp;quot;, border = NA,&#xA;&#x9;&#x9;col = rand_color(100, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.5))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-11-28-make-some-fun-circular-plots_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;768&#34; /&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;par(mar = c(1, 1, 1, 1))&#xA;layout(cbind(1:2), heights = c(1, 2))&#xA;&#xA;x0 = sort(runif(500))&#xA;x0 = matrix(x0, ncol = 2, byrow = TRUE)&#xA;x0 = x0[sample(nrow(x0), nrow(x0)), ]&#xA;x1 = sort(runif(500))&#xA;x1 = matrix(x1, ncol = 2, byrow = TRUE)&#xA;x1 = x1[sample(nrow(x1), nrow(x1)), ]&#xA;&#xA;l = abs(x0[, 1] - x1[, 1]) &amp;lt; 0.5&#xA;&#xA;x0 = x0[l, ]&#xA;x1 = x1[l, ]&#xA;plot(NULL, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, ann = FALSE)&#xA;&#xA;for (i in 1:100) {&#xA;&#x9;pt1 = circlize:::get_bezier_points(x0[i, 1], 0, x1[i, 1], 1, xlim = c(0, 1), ylim = c(0, 1))&#xA;&#x9;pt2 = circlize:::get_bezier_points(x0[i, 2], 0, x1[i, 2], 1, xlim = c(0, 1), ylim = c(0, 1))&#xA;&#xA;    polygon(c(x0[i, 1], x0[i, 2], pt2[, 1], rev(pt1[, 1])),&#xA;            c(0, 0, pt2[, 2], rev(pt1[, 2])), &#xA;    &#x9;col = rand_color(1, luminosity = &amp;quot;bright&amp;quot;, transparency = 0.5),&#xA;    &#x9;border = NA)&#xA;}&#xA;box(col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#xA;circos.initialize(c(&amp;quot;a&amp;quot;), xlim = c(0, 1))&#xA;circos.track(ylim = c(0, 1), track.height = 0.7, bg.border = NA, &#xA;&#x9;panel.fun = function(x, y) {&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[1], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#x9;circos.lines(CELL_META$cell.xlim, rep(CELL_META$cell.ylim[2], 2), col = &amp;quot;#CCCCCC&amp;quot;)&#xA;&#xA;&#x9;circos.connect(x0, 0, x1, 1, &#xA;&#x9;&#x9;type = &amp;quot;bezier&amp;quot;, border = NA,&#xA;&#x9;&#x9;col = rand_color(nrow(x0), luminosity = &amp;quot;bright&amp;quot;, transparency = 0.5))&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-11-28-make-some-fun-circular-plots_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;768&#34; /&gt;</description>
    </item>
    <item>
      <title>Visualize relations between genes and pathways</title>
      <link>/lab-cn/2020/11/27/visualize-relations-between-genes-and-pathways/</link>
      <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/11/27/visualize-relations-between-genes-and-pathways/</guid>
      <description>&lt;p&gt;@&lt;a href=&#34;https://github.com/venkan&#34;&gt;venkan&lt;/a&gt; provides &lt;a href=&#34;https://github.com/jokergoo/circlize/issues/236&#34;&gt;an interesting use&#xA;case&lt;/a&gt; for &lt;strong&gt;circlize&lt;/strong&gt;&#xA;which is to visualize the relations bewteen genes and pathways with&#xA;integrating genes&amp;rsquo; genomic positions. An example plot looks like:&lt;/p&gt;&#xA;&lt;img src=&#34;https://i.stack.imgur.com/8mQv4.jpg&#34; width=&#34;500&#34; /&gt;&#xA;&lt;p&gt;In that plot, the &amp;ldquo;pathway&amp;rdquo; is in the same track as the ideograms. Thus, to&#xA;use &lt;strong&gt;circlize&lt;/strong&gt; to implement it, we need to make &amp;ldquo;pathway&amp;rdquo; as a fake&#xA;chromosome and concatenate it to the normal chromosomes. In this blog post, I&#xA;will demonstrate how to implement it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Arrange links evenly along the sectors</title>
      <link>/lab-cn/2020/11/23/arrange-links-evenly-along-the-sectors/</link>
      <pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/11/23/arrange-links-evenly-along-the-sectors/</guid>
      <description>&lt;p&gt;People use &lt;code&gt;circos.link()&lt;/code&gt; to visualize interactions/relations between sectors.&#xA;When one sector has more than one other sectors to interact with, it actually&#xA;becomes important of how to arrange links on that sector to make every link readable.&lt;/p&gt;&#xA;&lt;p&gt;In the following example, I created a random interaction data frame &lt;code&gt;df&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(123)&#xA;sectors = letters[1:20]&#xA;df = data.frame(from = sample(sectors, 40, replace = TRUE),&#xA;                to   = sample(sectors, 40, replace = TRUE))&#xA;df = unique(df)&#xA;df = df[df$from != df$to, ]&#xA;df&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;##    from to&#xA;## 1     o  a&#xA;## 2     s  f&#xA;## 3     n  o&#xA;## 4     c  i&#xA;## 5     j  o&#xA;## 6     r  p&#xA;## 7     k  t&#xA;## 8     e  f&#xA;## 9     t  k&#xA;## 10    n  h&#xA;## 11    e  g&#xA;## 12    s  p&#xA;## 13    i  q&#xA;## 14    c  r&#xA;## 15    h  q&#xA;## 16    g  b&#xA;## 17    j  d&#xA;## 18    i  m&#xA;## 19    s  e&#xA;## 20    d  s&#xA;## 21    n  t&#xA;## 22    q  n&#xA;## 23    k  c&#xA;## 24    g  h&#xA;## 25    l  p&#xA;## 26    o  l&#xA;## 27    j  n&#xA;## 28    m  c&#xA;## 29    g  n&#xA;## 30    i  g&#xA;## 31    i  c&#xA;## 33    g  e&#xA;## 34    f  h&#xA;## 35    b  s&#xA;## 36    e  j&#xA;## 37    h  r&#xA;## 38    l  j&#xA;## 39    m  l&#xA;## 40    r  b&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I also created the corresponding circular plot with all the sectors. In the&#xA;simplest way, we might want to put all the links to the center of every&#xA;sector, which looks like follows:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Helper functions for genome-scale heatmap</title>
      <link>/lab-cn/2020/11/22/helper-functions-for-genome-scale-heatmap/</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/11/22/helper-functions-for-genome-scale-heatmap/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;../../../../2020/10/29/make-genome-scale-heatmap/&#34;&gt;In my previous blog&#xA;post&lt;/a&gt;, I&#xA;demonstrated how to make a genome-scale heatmap with multiple other tracks.&#xA;The key thing there is to split the genome into bins and to normalize various&#xA;genomic signals to average them into every bin of the genome. From&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; version 2.7.1.1003, I added some helper functions which&#xA;simplify the binning of the genome and the overlapping between genomic bins&#xA;and genomic signals with two new functions &lt;code&gt;bin_genome()&lt;/code&gt; and&#xA;&lt;code&gt;normalize_genomic_signals_to_bins()&lt;/code&gt;. Here I will introduce the usage of&#xA;these two functions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Make genome-scale heatmap</title>
      <link>/lab-cn/2020/10/29/make-genome-scale-heatmap/</link>
      <pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/10/29/make-genome-scale-heatmap/</guid>
      <description>&lt;p&gt;Many people are interested in making genome-scale heatmap with multiple&#xA;tracks, like examples &lt;a href=&#34;https://github.com/jokergoo/gtrellis/issues/4&#34;&gt;here&lt;/a&gt;&#xA;and&#xA;&lt;a href=&#34;https://www.biorxiv.org/content/biorxiv/early/2019/03/30/594267/F4.medium.gif&#34;&gt;here&lt;/a&gt;.&#xA;In this blog post, I will demonstrate how to implement it with&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;To make genome-scale plot, we first need the ranges on chromosome-level. There&#xA;are many ways to obtain this information. In following, I use&#xA;&lt;code&gt;circlize::read.chromInfo()&lt;/code&gt; function.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;library(GenomicRanges)&#xA;chr_df = read.chromInfo()$df&#xA;chr_df = chr_df[chr_df$chr %in% paste0(&amp;quot;chr&amp;quot;, 1:22), ]&#xA;chr_gr = GRanges(seqnames = chr_df[, 1], ranges = IRanges(chr_df[, 2] + 1, chr_df[, 3]))&#xA;chr_gr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## GRanges object with 22 ranges and 0 metadata columns:&#xA;##        seqnames      ranges strand&#xA;##           &amp;lt;Rle&amp;gt;   &amp;lt;IRanges&amp;gt;  &amp;lt;Rle&amp;gt;&#xA;##    [1]     chr1 1-249250621      *&#xA;##    [2]     chr2 1-243199373      *&#xA;##    [3]     chr3 1-198022430      *&#xA;##    [4]     chr4 1-191154276      *&#xA;##    [5]     chr5 1-180915260      *&#xA;##    ...      ...         ...    ...&#xA;##   [18]    chr18  1-78077248      *&#xA;##   [19]    chr19  1-59128983      *&#xA;##   [20]    chr20  1-63025520      *&#xA;##   [21]    chr21  1-48129895      *&#xA;##   [22]    chr22  1-51304566      *&#xA;##   -------&#xA;##   seqinfo: 22 sequences from an unspecified genome; no seqlengths&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In the final heatmap, each row (if the genomic direction is vertical) or each&#xA;column (if the genomic direction is horizontal) actually represents a genomic&#xA;window, thus we need to split the genome with equal-width windows. Here I use&#xA;&lt;code&gt;EnrichedHeatmap::makeWindows()&lt;/code&gt; function to split the genome by 1MB window&#xA;(The two meta-columns in &lt;code&gt;chr_window&lt;/code&gt; can be ignored here).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Recent improvements on legends</title>
      <link>/lab-cn/2020/10/29/recent-improvements-on-legends/</link>
      <pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/10/29/recent-improvements-on-legends/</guid>
      <description>&lt;p&gt;In this post, I will demonstrate several improvements on the legends in&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package (version 2.7.1).&lt;/p&gt;&#xA;&lt;p&gt;First I load the &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;discrete-legends&#34;&gt;Discrete legends&lt;/h2&gt;&#xA;&lt;p&gt;Now it works with multi-line labels:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lgd = Legend(labels = c(&amp;quot;aaaaa\naaaaa&amp;quot;, &amp;quot;bbbbb\nbbbbb&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;),&#xA;    legend_gp = gpar(fill = 1:4))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-11-02-recent-improvements-on-legends_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;71.0824146981627&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;When the multi-line legend labels are in different rows:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;lgd = Legend(labels = c(&amp;quot;aaaaa\naaaaa&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;bbbbb\nbbbbb&amp;quot;),&#xA;    legend_gp = gpar(fill = 1:4), nrow = 2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-11-02-recent-improvements-on-legends_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;134.072440944882&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;&lt;code&gt;Legend()&lt;/code&gt; function has a new argument &lt;code&gt;graphics&lt;/code&gt; where users can self-define the graphics&#xA;drawn in the legend. Check the following example:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Concatenate two genomes in the circular plot</title>
      <link>/lab-cn/2020/10/16/concatenate-two-genomes-in-the-circular-plot/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/10/16/concatenate-two-genomes-in-the-circular-plot/</guid>
      <description>&lt;p&gt;There are some scenarios where users want to visualize more than one genomes&#xA;in the circular plots. This can be done by making &amp;ldquo;a combined genome&amp;rdquo;. In the&#xA;following example, I combine both human and mouse genomes.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;human_cytoband = read.cytoband(species = &amp;quot;hg19&amp;quot;)$df&#xA;mouse_cytoband = read.cytoband(species = &amp;quot;mm10&amp;quot;)$df&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;One thing important is since the two genome will be combined, the chromosome&#xA;names for each genome need to be adjusted. Here I simply add &lt;code&gt;human_&lt;/code&gt;/&lt;code&gt;mouse_&lt;/code&gt;&#xA;prefix.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Visualize traffic intersection loads with Chord diagram</title>
      <link>/lab-cn/2020/10/13/visualize-traffic-intersection-loads-with-chord-diagram/</link>
      <pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/10/13/visualize-traffic-intersection-loads-with-chord-diagram/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.sankey-diagrams.com/traffic-load-visualization-using-sankey/&#34;&gt;In this blog&#xA;post&lt;/a&gt;,&#xA;the author demonstrated how to visualize the traffic loads with Sankey&#xA;diagram. It looks very nice and here I implemente it with Chord diagram.&lt;/p&gt;&#xA;&lt;p&gt;Following data frame contains data for the traffic loads, which is basically&#xA;the number of vehicles that travel through every two directions.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df = read.table(textConnection(&#xA;&amp;quot;B A 1000&#xA;C A 5000&#xA;D A 690&#xA;A B 2200&#xA;C B 1240&#xA;D B 5000&#xA;A C 5000&#xA;B C 2400&#xA;D C 2000&#xA;A D 2000&#xA;B D 3000&#xA;C D 3000&#xA;&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The colors for the four directions:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Integrate ComplexHeatmap with cowplot package</title>
      <link>/lab-cn/2020/07/14/integrate-complexheatmap-with-cowplot-package/</link>
      <pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/07/14/integrate-complexheatmap-with-cowplot-package/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/cowplot/index.html&#34;&gt;The &lt;strong&gt;cowplot&lt;/strong&gt; package&lt;/a&gt; is used&#xA;to combine multiple plots into a single figure. In most cases,&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; works perfectly with &lt;strong&gt;cowplot&lt;/strong&gt;, but there are some cases that need&#xA;special attention.&lt;/p&gt;&#xA;&lt;p&gt;Also there are some other packages that combine multiple plots, such&#xA;as &lt;a href=&#34;https://cran.r-project.org/web/packages/multipanelfigure/index.html&#34;&gt;&lt;strong&gt;multipanelfigure&lt;/strong&gt;&lt;/a&gt;,&#xA;but I think the mechanism behind is the same.&lt;/p&gt;&#xA;&lt;p&gt;Following functionalities in &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; cause problems with using &lt;strong&gt;cowplot&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://jokergoo.github.io/ComplexHeatmap-reference/book/heatmap-annotations.html#zoom-annotation&#34;&gt;&lt;code&gt;anno_zoom()&lt;/code&gt;/&lt;code&gt;anno_link()&lt;/code&gt;&lt;/a&gt;.&#xA;The adjusted positions by these two functions rely on the size of the graphics&#xA;device.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://jokergoo.github.io/ComplexHeatmap-reference/book/heatmap-annotations.html#mark-annotation&#34;&gt;&lt;code&gt;anno_mark()&lt;/code&gt;&lt;/a&gt;.&#xA;The same reason as &lt;code&gt;anno_zoom()&lt;/code&gt;. The adjusted positions also rely on the device size.&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://jokergoo.github.io/ComplexHeatmap-reference/book/legends.html#heatmap-and-annotation-legends&#34;&gt;When there are too many legends, the legends will be wrapped into multiple columns&lt;/a&gt;. The calculation&#xA;of the legend positions rely on the device size.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;In following I demonstrate a case with using the &lt;code&gt;anno_zoom()&lt;/code&gt;. Here the&#xA;example is from &lt;a href=&#34;https://github.com/jokergoo/simplifyEnrichment&#34;&gt;the &lt;strong&gt;simplifyEnrichment&lt;/strong&gt;&#xA;package&lt;/a&gt; and the plot shows a&#xA;GO similarity heatmap with word cloud annotation showing the major biological&#xA;functions in each group.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Block annotation over several slices</title>
      <link>/lab-cn/2020/07/06/block-annotation-over-several-slices/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/07/06/block-annotation-over-several-slices/</guid>
      <description>&lt;p&gt;In &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package, &lt;code&gt;anno_block()&lt;/code&gt; function draws rectangles for&#xA;row/column slices, like in the following plot. Then what if we want to draw the&#xA;rectangles over several slices to show they belong to certain groups?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(123)&#xA;mat = matrix(rnorm(50*50), nrow = 50)&#xA;library(ComplexHeatmap)&#xA;ha = HeatmapAnnotation(foo = anno_block(gp = gpar(fill = 2:6), labels = LETTERS[1:5]))&#xA;split = rep(1:5, each = 10)&#xA;Heatmap(mat, name = &amp;quot;mat&amp;quot;, column_split = split, top_annotation = ha, &#xA;&#x9;column_title = NULL)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-07-06-block-annotation-over-several-slices_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;480&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;Currently, it is difficult to directly support it in &lt;code&gt;anno_block()&lt;/code&gt;, however,&#xA;there is workaround for it. Actually, to draw rectangles across several&#xA;slices, we need to know two things: 1. the positions of the slices in the&#xA;plot, and 2. space to draw the rectangles. Luckily, the positions can be&#xA;obtained by directly go to the correspoding viewport and the space can be&#xA;allocated by &lt;code&gt;anno_empty()&lt;/code&gt; function.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rasterization in ComplexHeatmap</title>
      <link>/lab-cn/2020/06/30/rasterization-in-complexheatmap/</link>
      <pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/06/30/rasterization-in-complexheatmap/</guid>
      <description>&lt;p&gt;Guillaume Devailly recently wrote &lt;a href=&#34;https://gdevailly.netlify.app/post/plotting-big-matrices-in-r/&#34;&gt;an&#xA;article&lt;/a&gt; on&#xA;image rasterization to efficiently visualize huge matrices in R, as well as&#xA;comparing several R functions that support image rasterization. In this post, I&#xA;discusse the support for raster image in &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; in more details.&lt;/p&gt;&#xA;&lt;p&gt;When we produce so-called &amp;ldquo;high quality figures&amp;rdquo;, normally we save the figures&#xA;as &lt;a href=&#34;https://en.wikipedia.org/wiki/Vector_graphics&#34;&gt;vector graphics&lt;/a&gt; in the&#xA;format of &lt;em&gt;e.g.&lt;/em&gt; pdf or svg. The vector graphics basically store details of&#xA;every single graphic elements, thus, if a heatmap made from a very huge matrix is&#xA;saved as vector graphics, the final file size would be very big. On the other&#xA;hand, when visualizing &lt;em&gt;e.g.&lt;/em&gt; the pdf file on the screen, multiple grids from&#xA;the heatmap actually only map to single pixels, due to the limited size of the&#xA;screen. Thus, there need some ways to effectively reduce the original image and&#xA;it is not necessary to store the complete matrix for the heatmap.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Align heatmap legends</title>
      <link>/lab-cn/2020/06/29/align-heatmap-legends/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/06/29/align-heatmap-legends/</guid>
      <description>&lt;p&gt;In this post, I will demonstrate the automatic alignment of heatmap legends.&#xA;This new feature in avaiable in &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; &amp;gt;= 2.5.4.&lt;/p&gt;&#xA;&lt;p&gt;In the following heatmaps, I use a random 10x10 matrix generated as&#xA;follows:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;set.seed(123)&#xA;m = matrix(rnorm(100), 10)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In the older versions (&amp;lt;= 2.5.3), the legends are put in the middle of a&#xA;viewport which almost has the same height as the whole plot. It looks nice&#xA;when there are no column names in the heatmap.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Which heatmap function is faster?</title>
      <link>/lab-cn/2020/06/19/which-heatmap-function-is-faster/</link>
      <pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/06/19/which-heatmap-function-is-faster/</guid>
      <description>&lt;p&gt;In this post I test the performance (the running time) of four heatmap&#xA;functions: &lt;code&gt;gplots::heatmap.2()&lt;/code&gt;, &lt;code&gt;heatmap()&lt;/code&gt; which is natively supported in R,&#xA;&lt;code&gt;ComplexHeatmap::Heatmap()&lt;/code&gt; and &lt;code&gt;pheatmap::pheatmap()&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We generate a 1000x1000 random matrix.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;library(pheatmap)&#xA;library(gplots)&#xA;library(microbenchmark)&#xA;&#xA;set.seed(123)&#xA;n = 1000&#xA;mat = matrix(rnorm(n*n), nrow = n)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;First I test drawing heatmaps as well as drawing dendrograms (with applying&#xA;clustering):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;t1 = microbenchmark(&#xA;&#x9;&amp;quot;heatmap()&amp;quot; = {&#xA;&#x9;&#x9;pdf(NULL) &#xA;&#x9;&#x9;heatmap(mat) &#xA;&#x9;&#x9;dev.off()&#xA;&#x9;},&#xA;&#x9;&amp;quot;heatmap.2()&amp;quot; = {&#xA;&#x9;&#x9;pdf(NULL) &#xA;&#x9;&#x9;heatmap.2(mat, trace = &amp;quot;none&amp;quot;) &#xA;&#x9;&#x9;dev.off()&#xA;&#x9;},&#xA;&#x9;&amp;quot;Heatmap()&amp;quot; = {&#xA;&#x9;&#x9;pdf(NULL)&#xA;&#x9;&#x9;draw(Heatmap(mat)) &#xA;&#x9;&#x9;dev.off()&#xA;&#x9;},&#xA;&#x9;&amp;quot;pheatmap()&amp;quot; = {&#xA;&#x9;&#x9;pdf(NULL) &#xA;&#x9;&#x9;pheatmap(mat)&#xA;&#x9;&#x9;dev.off()&#xA;&#x9;},&#xA;&#x9;times = 5&#xA;)&#xA;print(t1, unit = &amp;quot;s&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;## Unit: seconds&#xA;##         expr   min    lq  mean median    uq   max neval&#xA;##    heatmap() 1.086 1.108 1.123  1.112 1.119 1.191     5&#xA;##  heatmap.2() 1.208 1.216 1.227  1.216 1.245 1.249     5&#xA;##    Heatmap() 2.026 2.092 2.239  2.108 2.316 2.652     5&#xA;##   pheatmap() 1.041 1.062 1.253  1.081 1.120 1.963     5&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The running time for all four heatmap functions looks similar, it might due to that&#xA;clustering uses most of the running time. &lt;code&gt;Heatmap()&lt;/code&gt; runs the longest, perhaps&#xA;because &lt;code&gt;Heatmap()&lt;/code&gt; applies additional manipulations on the dendrograms such as&#xA;dendrogram reordering.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multiple-group Chord diagram</title>
      <link>/lab-cn/2020/06/08/multiple-group-chord-diagram/</link>
      <pubDate>Mon, 08 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/06/08/multiple-group-chord-diagram/</guid>
      <description>&lt;p&gt;From verion 0.4.10 of the &lt;strong&gt;circlize&lt;/strong&gt; package, there is a new &lt;code&gt;group&lt;/code&gt;&#xA;argument in &lt;code&gt;chordDiagram()&lt;/code&gt; function which is very convenient for making&#xA;multiple-group Chord diagrams.&lt;/p&gt;&#xA;&lt;p&gt;I first generate a random matrix where there are three groups (&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;).&#xA;Note this new functionality works the same for the input as a data frame.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;mat1 = matrix(rnorm(25), nrow = 5)&#xA;rownames(mat1) = paste0(&amp;quot;A&amp;quot;, 1:5)&#xA;colnames(mat1) = paste0(&amp;quot;B&amp;quot;, 1:5)&#xA;&#xA;mat2 = matrix(rnorm(25), nrow = 5)&#xA;rownames(mat2) = paste0(&amp;quot;A&amp;quot;, 1:5)&#xA;colnames(mat2) = paste0(&amp;quot;C&amp;quot;, 1:5)&#xA;&#xA;mat3 = matrix(rnorm(25), nrow = 5)&#xA;rownames(mat3) = paste0(&amp;quot;B&amp;quot;, 1:5)&#xA;colnames(mat3) = paste0(&amp;quot;C&amp;quot;, 1:5)&#xA;&#xA;mat = matrix(0, nrow = 10, ncol = 10)&#xA;rownames(mat) = c(rownames(mat2), rownames(mat3))&#xA;colnames(mat) = c(colnames(mat1), colnames(mat2))&#xA;mat[rownames(mat1), colnames(mat1)] = mat1&#xA;mat[rownames(mat2), colnames(mat2)] = mat2&#xA;mat[rownames(mat3), colnames(mat3)] = mat3&#xA;mat&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;##        B1     B2     B3    B4    B5     C1     C2     C3    C4       C5&#xA;## A1 -0.085  0.016  0.091 -0.50 -1.27  0.051 -1.679  0.088 -0.76  0.01749&#xA;## A2  0.945 -0.107  1.274 -0.20  0.11  0.140 -0.711  1.380 -0.41 -0.99425&#xA;## A3 -0.414 -0.444  0.938 -0.36  0.55  1.389 -0.477 -1.159  0.80  0.25352&#xA;## A4 -0.898 -0.434  2.179 -0.16  1.58  1.377 -1.152 -2.465 -0.89 -0.40290&#xA;## A5  1.695 -0.799 -0.276  0.38  1.36 -0.141  0.234  1.819 -0.37 -0.00056&#xA;## B1  0.000  0.000  0.000  0.00  0.00  0.927  0.790 -1.152 -0.87  0.49555&#xA;## B2  0.000  0.000  0.000  0.00  0.00  0.602 -0.938  0.484  0.45  0.34223&#xA;## B3  0.000  0.000  0.000  0.00  0.00 -0.147 -0.763  0.149 -0.90  0.06670&#xA;## B4  0.000  0.000  0.000  0.00  0.00  0.208 -0.365  1.239 -1.23  0.82139&#xA;## B5  0.000  0.000  0.000  0.00  0.00 -0.622  0.022  0.262  1.45  0.23556&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The main thing is to create &amp;ldquo;a grouping variable&amp;rdquo;. The variable contains&#xA;the group labels and the sector names are used as the names in the vector.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Parse command-line arguments</title>
      <link>/lab-cn/2020/06/06/parse-command-line-arguments/</link>
      <pubDate>Sat, 06 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/06/06/parse-command-line-arguments/</guid>
      <description>&lt;style&gt;&#xA;pre.terminal {&#xA;&#x9;background: hsl(70, 0%, 15%);&#xA;&#x9;color: white;&#xA;}&#xA;pre.terminal .hljs {&#xA;&#x9;background: hsl(70, 0%, 15%);&#xA;&#x9;color: white;&#xA;}&#xA;&lt;/style&gt;&#xA;&lt;p&gt;There are already several R packages which parse command-line arguments such&#xA;as &lt;a href=&#34;https://CRAN.R-project.org/package=getopt&#34;&gt;&lt;strong&gt;getopt&lt;/strong&gt;&lt;/a&gt;,&#xA;&lt;a href=&#34;https://CRAN.R-project.org/package=optparse&#34;&gt;&lt;strong&gt;optparse&lt;/strong&gt;&lt;/a&gt;,&#xA;&lt;a href=&#34;https://CRAN.R-project.org/package=argparse&#34;&gt;&lt;strong&gt;argparse&lt;/strong&gt;&lt;/a&gt;,&#xA;&lt;a href=&#34;https://CRAN.R-project.org/package=docopt&#34;&gt;&lt;strong&gt;docopt&lt;/strong&gt;&lt;/a&gt;. Here&#xA;&lt;strong&gt;GetoptLong&lt;/strong&gt; is another command-line argument parser (actually it was&#xA;developed very early. &lt;a href=&#34;https://cran.r-project.org/src/contrib/Archive/GetoptLong/&#34;&gt;The first CRAN&#xA;version&lt;/a&gt; was in&#xA;2013) which wraps the powerful Perl module&#xA;&lt;a href=&#34;https://metacpan.org/pod/Getopt::Long&#34;&gt;&lt;code&gt;Getopt::Long&lt;/code&gt;&lt;/a&gt;. &lt;strong&gt;GetoptLong&lt;/strong&gt;&#xA;package also provides some adaptations for easier use in R.&lt;/p&gt;&#xA;&lt;p&gt;Using &lt;strong&gt;GetoptLong&lt;/strong&gt; is simple especially for users having Perl experience (Oops, age&#xA;exposed :)) because the specification is almost the same as in Perl. The&#xA;original website of&#xA;&lt;a href=&#34;https://metacpan.org/pod/Getopt::Long&#34;&gt;&lt;code&gt;Getopt::Long&lt;/code&gt;&lt;/a&gt; is always&#xA;your best reference.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Word cloud as heatmap annotation</title>
      <link>/lab-cn/2020/05/31/word-cloud-as-heatmap-annotation/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/05/31/word-cloud-as-heatmap-annotation/</guid>
      <description>&lt;p&gt;I am recently developing a new package&#xA;&lt;a href=&#34;https://github.com/jokergoo/simplifyEnrichment&#34;&gt;simplifyEnrichment&lt;/a&gt; which&#xA;clusters GO terms into clusters and visualizes the summaries of GO terms in&#xA;each cluster as word cloud. The results are visualized by &lt;strong&gt;ComplexHeatmap&lt;/strong&gt;&#xA;where the word clouds are the heatmap annotations. In this post, I will&#xA;describe how to implement word clouds as the heatmap annotation by&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;To achieve this, we need two functionalities: one draws the word cloud and one&#xA;links the word cloud to the corresponding rows in the heatmap. The former is&#xA;done with the &lt;code&gt;word_cloud_grob()&lt;/code&gt; function that I will describe later and the&#xA;latter is done with &lt;code&gt;anno_link()&lt;/code&gt; function which is already defined in&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Make circular heatmaps</title>
      <link>/lab-cn/2020/05/21/make-circular-heatmaps/</link>
      <pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/05/21/make-circular-heatmaps/</guid>
      <description>&lt;p&gt;Circular heatmaps are pretty. With &lt;strong&gt;circlize&lt;/strong&gt; package, &lt;a href=&#34;https://jokergoo.github.io/circlize_book/book/high-level-plots.html#heatmaps&#34;&gt;it is possible to&#xA;implement circular heatmaps by the low-level function&#xA;&lt;code&gt;circos.rect()&lt;/code&gt;&lt;/a&gt;.&#xA;From version 0.4.10, I implemented a new high-level function &lt;code&gt;circos.heatmap()&lt;/code&gt; which&#xA;simplifies the creation of circular heatmaps. In this post, I will demostrate&#xA;the usage of the new &lt;code&gt;circos.heatmap()&lt;/code&gt; function.&lt;/p&gt;&#xA;&lt;p&gt;First let&amp;rsquo;s generate a random matrix and randomly split it into five groups.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(123)&#xA;mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), &#xA;                   matrix(rnorm(50*5, mean = -1), nr = 50)),&#xA;             cbind(matrix(rnorm(50*5, mean = -1), nr = 50), &#xA;                   matrix(rnorm(50*5, mean = 1), nr = 50))&#xA;            )&#xA;rownames(mat1) = paste0(&amp;quot;R&amp;quot;, 1:100)&#xA;colnames(mat1) = paste0(&amp;quot;C&amp;quot;, 1:10)&#xA;mat1 = mat1[sample(100, 100), ] # randomly permute rows&#xA;split = sample(letters[1:5], 100, replace = TRUE)&#xA;split = factor(split, levels = letters[1:5])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Following plot is the normal layout of the heatmap (by &lt;a href=&#34;https://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html&#34;&gt;the &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Set cell width/height in the heatmap</title>
      <link>/lab-cn/2020/05/11/set-cell-width/height-in-the-heatmap/</link>
      <pubDate>Mon, 11 May 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/05/11/set-cell-width/height-in-the-heatmap/</guid>
      <description>&lt;p&gt;When making a heatmap, the width and height of heatmap cells are automatically&#xA;adjusted to fill in the figure (e.g. the following figure), which means, when&#xA;you change the width and height of the final figure, the width and height of&#xA;the cells change accordingly.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ComplexHeatmap)&#xA;set.seed(123)&#xA;mat = matrix(rnorm(100), 10)&#xA;Heatmap(mat, name = &amp;quot;mat&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2020-05-11-set-cell-width-height-in-the-heatmap_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&#xA;&lt;p&gt;When the matrix is small, there are scenarios where you might want to manually&#xA;set the width and height of cells to fixed values, so that you can, &lt;em&gt;e.g.&lt;/em&gt;,&#xA;put proper row/column labels or to make it easy to compare to other heatmaps&#xA;with different dimensions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Translate from pheatmap to ComplexHeatmap</title>
      <link>/lab-cn/2020/05/06/translate-from-pheatmap-to-complexheatmap/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2020/05/06/translate-from-pheatmap-to-complexheatmap/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;pheatmap&lt;/strong&gt; is a great R package for making heatmaps, inspiring a lot of other&#xA;heatmap packages such as &lt;strong&gt;ComplexHeatmap&lt;/strong&gt;. From version 2.5.2 of&#xA;&lt;strong&gt;ComplexHeatmap&lt;/strong&gt;, I implemented a new &lt;code&gt;ComplexHeatmap::pheatmap()&lt;/code&gt; function&#xA;which actually maps all the parameters in &lt;code&gt;pheatmap::pheatmap()&lt;/code&gt; to proper&#xA;parameters in &lt;code&gt;ComplexHeatmap::Heatmap()&lt;/code&gt;, which means, it converts a pheatmap&#xA;to a complex heatmap. By doing this, the most significant improvement is now you&#xA;can add multiple pheatmaps and annotations (defined by&#xA;&lt;code&gt;ComplexHeatmap::rowAnnotation()&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Substitute with an evaluated expression</title>
      <link>/lab-cn/2019/10/06/substitute-with-an-evaluated-expression/</link>
      <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2019/10/06/substitute-with-an-evaluated-expression/</guid>
      <description>&lt;p&gt;In Perl, if we want to substitute with an evaluated expression with regular&#xA;expression, we can do as follows.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;%map = (&#xA;&#x9;&amp;quot;a&amp;quot; =&amp;gt; &amp;quot;one&amp;quot;,&#xA;&#x9;&amp;quot;b&amp;quot; =&amp;gt; &amp;quot;two&amp;quot;,&#xA;&#x9;&amp;quot;c&amp;quot; =&amp;gt; &amp;quot;three&amp;quot;,&#xA;);&#xA;$txt = &amp;quot;a, b, c&amp;quot;;&#xA;$txt =~s/([a|b|c])/$map{$1}/g;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Here &lt;code&gt;$map{$1}&lt;/code&gt; is evaluated and &lt;code&gt;$txt&lt;/code&gt; will be &lt;code&gt;one, two, three&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;To be formal, the matched text &lt;em&gt;s&lt;/em&gt; is replaced by &lt;em&gt;f(s)&lt;/em&gt; where &lt;em&gt;f()&lt;/em&gt; is a&#xA;transformation to the text &lt;em&gt;s&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Put Chord diagram horizontally or vertically symmetric</title>
      <link>/lab-cn/2017/03/17/put-chord-diagram-horizontally-or-vertically-symmetric/</link>
      <pubDate>Fri, 17 Mar 2017 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2017/03/17/put-chord-diagram-horizontally-or-vertically-symmetric/</guid>
      <description>&lt;p&gt;In Chord diagram, when there are two groups (which correspond to rows and columns&#xA;if the input is a adjacency matrix), it is always visually beautiful to rotate the diagram&#xA;to be symmetric on horizontal direction or vertical direction. Actually it is quite easy&#xA;to calculate a proper degree that needs to be rotated for the circle. In this post,&#xA;I will show how to calculate such kind of &amp;ldquo;rotated degree value&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Reverse x-axis in the circular layout</title>
      <link>/lab-cn/2016/11/21/reverse-x-axis-in-the-circular-layout/</link>
      <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2016/11/21/reverse-x-axis-in-the-circular-layout/</guid>
      <description>&lt;p&gt;In &lt;strong&gt;circlize&lt;/strong&gt; package, x-axis in always clockwise in each sector, no matter it&#xA;is on the top of the circle or at the bottom. However, you can manually reverse&#xA;the original positions on x-axis to pretend you have a reversed x-axis. Take following example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(circlize)&#xA;circos.par(gap.degree = c(10, 10), start.degree = -5)&#xA;circos.initialize(factors = c(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;), xlim = c(0, 1))&#xA;circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {&#xA;&#x9;circos.axis(major.at = seq(0, 1, by = 0.1))&#xA;})&#xA;circos.rect(0.2, 0.2, 0.4, 0.4, col = &amp;quot;red&amp;quot;, sector.index = &amp;quot;a&amp;quot;)&#xA;circos.link(&amp;quot;a&amp;quot;, 0.3, &amp;quot;b&amp;quot;, 0.7)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;img src=&#34;/lab-cn/post/2016-11-21-reverse-xaxis-in-the-circular-layout_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;768&#34; /&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;circos.clear()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In the bottom sector, the order of x-axis seems not very convinient to read.&#xA;Actually we can make some transformation on the original coordinates on x-axis.&#xA;In following we defined &lt;code&gt;reverse_xaxis()&lt;/code&gt; which flips the x-axis.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Visualize positive and negative signals in the enriched heatmap</title>
      <link>/lab-cn/2016/11/21/visualize-positive-and-negative-signals-in-the-enriched-heatmap/</link>
      <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
      <guid>/lab-cn/2016/11/21/visualize-positive-and-negative-signals-in-the-enriched-heatmap/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/jokergoo/EnrichedHeatmap&#34;&gt;Enriched heatmaps&lt;/a&gt; are used to visualize the enrichment&#xA;of genomic signals on a set of genomic targets of interest. It is broadly used to visualize e.g. how&#xA;histone marks are enriched to specific sites.&lt;/p&gt;&#xA;&lt;p&gt;Sometimes we want to visualize the general correlation around certain genomic targets or how the difference&#xA;between two subgroups looks like in the vicinity of e.g. gene TSS. In this case, the signals contain both&#xA;positive and negative value and it makes more sense to visualize the enrichment for the positive and&#xA;negative signals separatedly.&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>/lab-cn/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/lab-cn/1/01/01/</guid>
      <description>&lt;script src=&#34;2020-11-27-visualize-relations-between-genes-and-pathways-with-integrating-their-genomic-positios_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link href=&#34;2020-11-27-visualize-relations-between-genes-and-pathways-with-integrating-their-genomic-positios_files/anchor-sections/anchor-sections.css&#34; rel=&#34;stylesheet&#34; /&gt;&#xA;&lt;script src=&#34;2020-11-27-visualize-relations-between-genes-and-pathways-with-integrating-their-genomic-positios_files/anchor-sections/anchor-sections.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;&#xA;&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123)&#xA;library(circlize)&#xA;df = generateRandomBed(30)[ , 1:3]&#xA;df[, 3] = df[, 2]&#xA;df$gene = paste0(&amp;quot;gene_&amp;quot;, 1:nrow(df))&#xA;df$pathway = paste0(&amp;quot;pathway_&amp;quot;, sample(10, nrow(df), replace = TRUE))&#xA;&#xA;cytoband = read.cytoband()$df&#xA;&#xA;cytoband = rbind(cytoband,&#xA;    data.frame(V1 = &amp;quot;pathway&amp;quot;, V2 = 1,  V3 = 2e8, V4 = &amp;quot;&amp;quot;, V5 = &amp;quot;&amp;quot;))&#xA;&#xA;foo = as.integer(round(seq(1, 2e8, length = 11)))&#xA;pathway_mid = structure((foo[1:10] + foo[2:11])/2, names = paste0(&amp;quot;pathway_&amp;quot;, 1:10))&#xA;&#xA;df$pathway_chr = &amp;quot;pathway&amp;quot;&#xA;df$pathway_start = pathway_mid[ df$pathway ]&#xA;df$pathway_end = pathway_mid[ df$pathway ]&#xA;&#xA;circos.initializeWithIdeogram(cytoband)&#xA;circos.genomicLink(df[, 1:3], df[, 6:8])&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;img src=&#34;2020-11-27-visualize-relations-between-genes-and-pathways-with-integrating-their-genomic-positios_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
