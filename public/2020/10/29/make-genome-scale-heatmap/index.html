<!DOCTYPE html>
<html lang="en-US">
  <head><script src="/lab-cn/livereload.js?mindelay=10&amp;v=2&amp;port=4321&amp;path=lab-cn/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="A website built through Hugo and blogdown.">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>


    
      <link href="https://fonts.googleapis.com/css?family=Open+Sans:400|Old+Standard+TT:400&display=swap" rel="stylesheet" media="print" type="text/css" onload="this.media='all'">
    

    


<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />




    <title>
      
      
         Make genome-scale heatmap 
      
    </title>
    <link rel="canonical" href="http://localhost:4321/lab-cn/2020/10/29/make-genome-scale-heatmap/">

    <style>
  * {
    border:0;
    font:inherit;
    vertical-align:baseline;
    margin:0;
    padding:0;
    color: black;
    text-decoration-skip: ink;
    overflow-wrap: break-word;
  }

  body {
    font-family: Georgia,serif;
    line-height:160%;
    color:#1d1313;
    max-width:1000px;
    margin:auto;
    min-height: 600px;
    font-size: 17px;
  }

  p {
    margin: 20px 0;
  }

  a img {
    border:none;
  }

  img {
    margin: 10px auto 10px auto;
    max-width: 100%;
    display: block;
  }

  .left-justify { float: left; }
  .right-justify { float:right; }

  pre, code {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
    background-color: #f7f7f7;
  }

  code {
    padding: 4px;
  }

  pre {
    margin-top: 0;
    margin-bottom: 16px;
    word-wrap: normal;
    padding: 16px;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
  }

  pre>code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    word-break: normal;
    white-space: pre;
    background: transparent;
    border: 0;
  }

  pre code {
    display: inline;
    padding: 0;
    margin: 0;
    overflow: visible;
    line-height: inherit;
    word-wrap: normal;
    background-color: transparent;
    border: 0;
  }

  pre code::before,
  pre code::after {
    content: normal;
  }

  em,q,em,dfn {
    font-style:italic;
  }

  .sans,html .gist .gist-file .gist-meta {
    font-family:"Open Sans","Myriad Pro",Myriad,sans-serif;
  }

  .mono,pre,code,tt,p code,li code {
    font-family:Menlo,Monaco,"Andale Mono","lucida console","Courier New",monospace;
  }

  strong {
    font-weight:600;
  }

  q:before {
    content:"\201C";
  }

  q:after {
    content:"\201D";
  }

  del,s {
    text-decoration:line-through;
  }

  blockquote {
    font-family:"Old Standard TT",serif;
    text-align:center;
    padding:50px;
  }

  blockquote p {
    display:inline-block;
    font-style:italic;
  }

  blockquote:before,blockquote:after {
    font-family:"Old Standard TT",serif;
    content:'\201C';
    color:#403c3b;
  }

  blockquote:after {
    content:'\201D';
  }

  hr {
    width:40%;
    height: 1px;
    background:#403c3b;
    margin: 25px auto;
  }


  h2, h3 {
    margin-top: 40px;
    margin-bottom: 20px;
  }

  h1 a,h2 a,h3 a {
    text-decoration:none;
  }

  h1,h2 {
    margin-top:28px;
  }

  h1 {
    font-size: 2em;
  }

  h2, h3 {
    font-size: 1.5em;
  }

  #sub-header, .date {
    color:#403c3b;
  }

  #sub-header {
    margin: 0 4px;
    font-style: italic;
  }

  #nav h1 a {
    color:#1d1313;
    line-height:120%;
  }

  .posts_listing a,#nav a {
    text-decoration: none;
  }

  li {
    margin-left: 20px;
  }

  ul li {
    margin-left: 20px;
    padding-top: 2px;
    padding-bottom: 2px;
  }


  #nav ul li:before, .posts_listing li:before {
    content:'';
    margin-right:0;
  }

  #content {
    text-align:left;
    width:100%;
    padding:30px 0 80px;
  }

  #content h1,#content h2 {
    margin-bottom:5px;
  }

  #content .entry-content {
    margin-top:15px;
  }

  #content .date {
    margin-left:3px;
  }


  .highlight {
    margin: 10px 0;
  }

  .posts_listing {
    margin:0 0 50px;
  }

  .posts_listing li {
    margin:0 0 25px 15px;
  }

 
  #nav {
    text-align:center;
    position:static;
    margin-top:60px;
  }

  a {
    text-decoration: underline;
    text-decoration-color: #CCC;
    text-underline-offset: 5px;
  }

  a:hover {
    text-decoration-color: black;
  }

  
  #nav li {
    list-style-type:none;
    display:table-cell;
    padding: 0 20px;
  }

  #links {
    display: flex;
    justify-content: space-between;
    margin: 50px 0 0 0;
  }

  #links :nth-child(1) {
    margin-right:0.5em;;
  }

  #links :nth-child(2) {
    margin-left:0.5em;;
  }

  #not-found {
    text-align: center;
  }

  #not-found a {
    font-size: 3em;
    text-decoration: none;
    display: inline-block;
    padding-top: 225px;
    padding-bottom: 225px;
  }


#soft-info table td {
  padding: 2px 10px 2px 0px;
}


  @media (max-width: 750px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:28px;
    }

    #nav li {
      font-size:13px;
      padding: 0 5px;
    }

    #content {
      margin-top:0;
      padding-top:50px;
      font-size:14px;
    }

    #content h1 {
      font-size:25px;
    }

    #content h2 {
      font-size:22px;
    }

    .posts_listing li div {
      font-size:12px;
    }
  }

  @media (max-width: 400px) {
    body {
      padding-left:20px;
      padding-right:20px;
    }

    #nav h1 a {
      font-size:22px;
    }

    #nav li {
      font-size:12px;
      padding: 0 5px;
    }

    #content {
      margin-top:0;
      padding-top:20px;
      font-size:12px;
    }

    #content h1 {
      font-size:20px;
    }

    #content h2 {
      font-size:18px;
    }

    .posts_listing li div{
      font-size:12px;
    }
  }

  @media (prefers-color-scheme: dark) {
    *, #nav h1 a {
      color: #FDFDFD;
    }

    body {
      background: #121212;
    }

    pre, code {
      background-color: #262626;
    }

    #sub-header, .date {
      color: #BABABA;
    }

    hr {
      background: #EBEBEB;
    }
  }
</style>


    </head>
<style>
#nav-logo-text {
    float: left;
    margin-top: 0px;
    margin-left: 0px;
    font-size: 2em;
    font-weight: 100;
}
#at {
  font-size:24px;
  padding:0px 2px;
}
</style>
<script>
window.root_dir = "http:\/\/localhost:4321\/lab-cn\/";
const regex = /^https?:\/\/[^/]+?\//;
root_dir = root_dir.replace(regex, "/");
$( function() {
  $("#content img").each(function(i) {
        var old_src = $(this).attr("src");
        var pattern = new RegExp("^" + root_dir);
        if(!pattern.test(old_src)) {
            pattern = /^http(s):\/\//;
            if(!pattern.test(old_src)) {
                $(this).attr("src", root_dir + "/" + old_src);
            }
        }
    });
  $("#nav-logo-text").attr("href", root_dir);
  $("#no-found-a").attr("href", root_dir);

  var url = window.location.href;
  var pattern = /lab-cn/;
  var url2 = url.replace(pattern, "lab-en");
  $("#nav ul li:last-child a").attr("href", url2);
})
</script>
  <body>
    <section id=nav>
      <h1><a class="h-card" href="/"></a></h1>
      <a href="#" id="nav-logo-text">Gu<span style="padding:0px 2px">.</span>Z<span id="at">@</span>SUAT-SZ</a>
      <ul style="float:right">
        
          <li><a href="/lab-cn/research/">研究</a></li>
        
          <li><a href="/lab-cn/publication/">论文</a></li>
        
          <li><a href="/lab-cn/software/">软件</a></li>
        
          <li><a href="/lab-cn/post">文章</a></li>
        
          <li><a href="/lab-cn/members/">成员</a></li>
        
          <li><a href="/lab-cn/opening/">职位</a></li>
        
          <li><a href="/lab-en/">EN</a></li>
        
      </ul>
      <div style="clear:both"></div>
    </section>


<section id=content>
  <h1 style="margin-bottom: 40px"> Make genome-scale heatmap </h1>

  
    <div id=sub-header>
      Zuguang Gu · October 2020
    </div>
  

  <div class="entry-content">
    <p>Many people are interested in making genome-scale heatmap with multiple
tracks, like examples <a href="https://github.com/jokergoo/gtrellis/issues/4">here</a>
and
<a href="https://www.biorxiv.org/content/biorxiv/early/2019/03/30/594267/F4.medium.gif">here</a>.
In this blog post, I will demonstrate how to implement it with
<strong>ComplexHeatmap</strong>.</p>
<p>To make genome-scale plot, we first need the ranges on chromosome-level. There
are many ways to obtain this information. In following, I use
<code>circlize::read.chromInfo()</code> function.</p>
<pre><code class="language-r">library(circlize)
library(GenomicRanges)
chr_df = read.chromInfo()$df
chr_df = chr_df[chr_df$chr %in% paste0(&quot;chr&quot;, 1:22), ]
chr_gr = GRanges(seqnames = chr_df[, 1], ranges = IRanges(chr_df[, 2] + 1, chr_df[, 3]))
chr_gr
</code></pre>
<pre><code>## GRanges object with 22 ranges and 0 metadata columns:
##        seqnames      ranges strand
##           &lt;Rle&gt;   &lt;IRanges&gt;  &lt;Rle&gt;
##    [1]     chr1 1-249250621      *
##    [2]     chr2 1-243199373      *
##    [3]     chr3 1-198022430      *
##    [4]     chr4 1-191154276      *
##    [5]     chr5 1-180915260      *
##    ...      ...         ...    ...
##   [18]    chr18  1-78077248      *
##   [19]    chr19  1-59128983      *
##   [20]    chr20  1-63025520      *
##   [21]    chr21  1-48129895      *
##   [22]    chr22  1-51304566      *
##   -------
##   seqinfo: 22 sequences from an unspecified genome; no seqlengths
</code></pre>
<p>In the final heatmap, each row (if the genomic direction is vertical) or each
column (if the genomic direction is horizontal) actually represents a genomic
window, thus we need to split the genome with equal-width windows. Here I use
<code>EnrichedHeatmap::makeWindows()</code> function to split the genome by 1MB window
(The two meta-columns in <code>chr_window</code> can be ignored here).</p>
<pre><code class="language-r">library(EnrichedHeatmap)
chr_window = makeWindows(chr_gr, w = 1e6)
chr_window
</code></pre>
<pre><code>## GRanges object with 2875 ranges and 2 metadata columns:
##          seqnames            ranges strand |  .i_query .i_window
##             &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;integer&gt;
##      [1]     chr1         1-1000000      * |         1         1
##      [2]     chr1   1000001-2000000      * |         1         2
##      [3]     chr1   2000001-3000000      * |         1         3
##      [4]     chr1   3000001-4000000      * |         1         4
##      [5]     chr1   4000001-5000000      * |         1         5
##      ...      ...               ...    ... .       ...       ...
##   [2871]    chr22 46000001-47000000      * |        22        47
##   [2872]    chr22 47000001-48000000      * |        22        48
##   [2873]    chr22 48000001-49000000      * |        22        49
##   [2874]    chr22 49000001-50000000      * |        22        50
##   [2875]    chr22 50000001-51000000      * |        22        51
##   -------
##   seqinfo: 22 sequences from an unspecified genome; no seqlengths
</code></pre>
<p>To visualize genome-scale signals as a heatmap as well as other tracks, now
the task is to calculate the average signals in the 1MB windows by overlapping
the genomic windows and the genomic signals. Here I implement a function
<code>average_in_window()</code>. This function is adapted from <a href="https://bioconductor.org/packages/HilbertCurve/"><strong>HilbertCurve</strong>
package</a> since there is
similar task there.</p>
<pre><code class="language-r">average_in_window = function(window, gr, v, method = &quot;weighted&quot;, empty_v = NA) {

	if(missing(v)) v = rep(1, length(gr))
	if(is.null(v)) v = rep(1, length(gr))
	if(is.atomic(v) &amp;&amp; is.vector(v)) v = cbind(v)

	v = as.matrix(v)
	if(is.character(v) &amp;&amp; ncol(v) &gt; 1) {
		stop(&quot;`v` can only be a character vector.&quot;)
	}

	if(length(empty_v) == 1) {
		empty_v = rep(empty_v, ncol(v))
	}

	u = matrix(rep(empty_v, each = length(window)), nrow = length(window), ncol = ncol(v))

	mtch = as.matrix(findOverlaps(window, gr))
 	intersect = pintersect(window[mtch[,1]], gr[mtch[,2]])
 	w = width(intersect)
 	v = v[mtch[,2], , drop = FALSE]
 	n = nrow(v)

 	ind_list = split(seq_len(n), mtch[, 1])
 	window_index = as.numeric(names(ind_list))
 	window_w = width(window)

 	if(is.character(v)) {
 		for(i in seq_along(ind_list)) {
 			ind = ind_list[[i]]
 			if(is.function(method)) {
 				u[window_index[i], ] = method(v[ind], w[ind], window_w[i])
 			} else {
 				tb = tapply(w[ind], v[ind], sum)
				u[window_index[i], ] = names(tb[which.max(tb)])
			}
		}
 	} else {
	 	if(method == &quot;w0&quot;) {
			gr2 = reduce(gr, min.gapwidth = 0)
			mtch2 = as.matrix(findOverlaps(window, gr2))
			intersect2 = pintersect(window[mtch2[, 1]], gr2[mtch2[, 2]])

			width_intersect = tapply(width(intersect2), mtch2[, 1], sum)
			ind = unique(mtch2[, 1])
			width_setdiff = width(window[ind]) - width_intersect

			w2 = width(window[ind])

			for(i in seq_along(ind_list)) {
				ind = ind_list[[i]]
				x = colSums(v[ind, , drop = FALSE]*w[ind])/sum(w[ind])
				u[window_index[i], ] = (x*width_intersect[i] + empty_v*width_setdiff[i])/w2[i]
			}

		} else if(method == &quot;absolute&quot;) {
			for(i in seq_along(ind_list)) {
				u[window_index[i], ] = colMeans(v[ind_list[[i]], , drop = FALSE])
			}
			
		} else if(method == &quot;weighted&quot;) {
			for(i in seq_along(ind_list)) {
				ind = ind_list[[i]]
				u[window_index[i], ] = colSums(v[ind, , drop = FALSE]*w[ind])/sum(w[ind])
			}
		} else {
			if(is.function(method)) {
				for(i in seq_along(ind_list)) {
		 			ind = ind_list[[i]]
		 			u[window_index[i], ] = method(v[ind], w[ind], window_w[i])
				}
			} else {
				stop(&quot;wrong method.&quot;)
			}
		}
	}

	return(u)
}
</code></pre>
<p>In <code>average_in_window()</code> function, there are following arguments:</p>
<ul>
<li><code>window</code>: A <code>GRanges</code> object of the genomic windows.</li>
<li><code>gr</code>: A <code>GRanges</code> object of the genomic signals.</li>
<li><code>v</code>: A vector or a matrix. This is the value associated with <code>gr</code> and it should have
the same length or <code>nrow</code> as <code>gr</code>. <code>v</code> can be numeric or character. If it is
<code>missing</code> or <code>NULL</code>, a value of one is assign to every region in <code>gr</code>. If <code>v</code> is numeric,
it can be a vector or a matrix, and if <code>v</code> is character, it can only be a vector.</li>
<li><code>method</code>: Method to summarize the signals for every genomic window.</li>
<li><code>empty_v</code>: The default value for the window if no region in <code>gr</code> overlaps to it.</li>
</ul>
<p>The function returns a matrix with the same row length and order as <code>window</code>.</p>
<p>The overlapping model is illustrated in the following plot. The red line in
the bottom represents a certain genomic window. Black lines on the top are the regions
for genomic signals that overlap with the window. The thick lines indicate the
intersected part between the signal regions and the window.</p>
<img src="/lab-cn/post/2020-10-29-make-genome-scale-heatmap_files/figure-html/unnamed-chunk-5-1.png" width="480" style="display: block; margin: auto;" />
<p>For a given window, <code>\(n\)</code> is the number of signal regions which overlap with the
window (it is 5 in the above plot), <code>\(w_i\)</code> is the width of the intersected
segments (black thick lines), and <code>\(x_i\)</code> is the signal value associated with
the original regions.</p>
<ol>
<li>
<p><strong>If the signals are numeric, either as a vector or a matrix</strong>, there are three pre-defined methods:</p>
<p>The <strong>&ldquo;absolute&rdquo;</strong> method is denoted as <code>\(v_a\)</code> and is simply calculated as the mean
of all signal regions regardless of their width.</p>
<p>$$ v_a = \frac{\sum_i^n{x_i}}{n} $$</p>
<p>The <strong>&ldquo;weighted&rdquo;</strong> method is denoted as <code>\(v_w\)</code> and is calculated as the mean of all
signal regions weighted by the width of their intersections. This is the default
method for numeric signals.</p>
<p>$$ v_w = \frac{\sum_i^n{x_iw_i}}{\sum_i^n{w_i}} $$</p>
<p>&ldquo;Absolute&rdquo; and &ldquo;weighted&rdquo; methods should be applied when background values
should not be taken into consideration. For example, when summarizing the mean
methylation in a small window, non-CpG background should be ignored, because
methylation is only associated with CpG sites and not with other positions.</p>
<p>The <strong>&ldquo;w0&rdquo;</strong> method is the weighted mean between the intersected parts and
un-intersected parts.</p>
<p>$$ v_{w0} = \frac{v_wW}{W+W&rsquo;} $$</p>
<p><code>\(W\)</code> is sum of width of the intersected parts (<code>\(\sum_i^n{w_i}\)</code>) and <code>\(W'\)</code> is the
sum of width for the non-intersected parts.</p>
</li>
<li>
<p><strong>If the signals are as a character vector,</strong> denote all levels encoded in <code>\(x_i\)</code>
as <code>\(A\)</code> and a certain level of <code>\(A\)</code> is denoted as <code>\(a\)</code>, the final value assigned to the
window is the level of which the corresponding segments have the maximal sum of widths.</p>
<p><code>$$\underset{a\in A}{\operatorname{arg\,max}}\sum_{i}^n I(x_i=a)\cdot w_i$$</code></p>
</li>
</ol>
<p>According to these rules, when the signal value <code>v</code> is numeric, the argumemt <code>method</code>
can be one of <code>weighted</code> (default), <code>absolute</code> and <code>w0</code>, and when <code>v</code> is character,
the value for <code>method</code> is ignored.</p>
<p>Besides the pre-defined values, <code>method</code> can also be a user-defined function and it works
both for numeric signals and character signals. The user-defined function should accept
three arguments: <code>x</code>, <code>w</code> and <code>gw</code>. This function is applied to every genomic window.
The three arguments are:</p>
<ul>
<li><code>x</code>: The signal values that fall in the genomic window (as shown in the previous plot).</li>
<li><code>w</code>: The associated segment widths.</li>
<li><code>gw</code>: The width of the current genomic window.</li>
</ul>
<p>The user-defined function should only return a scalar variable.</p>
<p>OK, now with the function <code>average_in_window()</code>, I can convert the genomic
signals to a window-based matrix. In the following example, I generate
approximately 1000 random genomic regions with 10 columns of random values (to
simulate 10 samples).</p>
<pre><code class="language-r">bed1 = generateRandomBed(nr = 1000, nc = 10) # generateRandomBed() is from circlize package
# convert to a GRanes object
gr1 = GRanges(seqnames = bed1[, 1], ranges = IRanges(bed1[, 2], bed1[, 3]))

num_mat = average_in_window(chr_window, gr1, bed1[, -(1:3)])
dim(num_mat)
</code></pre>
<pre><code>## [1] 2875   10
</code></pre>
<pre><code class="language-r">head(num_mat)
</code></pre>
<pre><code>##          [,1]    [,2]   [,3]     [,4]    [,5]    [,6]    [,7]    [,8]   [,9]
## [1,] -0.09896 -0.4766 0.3475  0.42086  0.1057 0.09644 -0.4471 -0.3294 0.6612
## [2,] -0.09896 -0.4766 0.3475  0.42086  0.1057 0.09644 -0.4471 -0.3294 0.6612
## [3,] -0.09896 -0.4766 0.3475  0.42086  0.1057 0.09644 -0.4471 -0.3294 0.6612
## [4,]       NA      NA     NA       NA      NA      NA      NA      NA     NA
## [5,]  0.98833 -1.1885 0.4948 -0.02239 -0.8126 0.08107  0.1432 -0.7425 0.4184
## [6,]  0.98833 -1.1885 0.4948 -0.02239 -0.8126 0.08107  0.1432 -0.7425 0.4184
##         [,10]
## [1,]  0.00805
## [2,]  0.00805
## [3,]  0.00805
## [4,]       NA
## [5,] -1.14188
## [6,] -1.14188
</code></pre>
<p>The first five genomic windows have no value associated because no region in
<code>gr1</code> overlaps to them, thus, they take the value from <code>empty_v</code> which is by
default <code>NA</code>.</p>
<p>The second data to visualize is 10 lists of genomic regions with character
signals (let&rsquo;s assume they are copy number variation results from 10 samples).
In each random regions, I additionally sample 20 from them, just to make them
sparse in the genome.</p>
<pre><code class="language-r">bed_list = lapply(1:10, function(i) {
	generateRandomBed(nr = 1000, nc = 1, 
		fun = function(n) sample(c(&quot;gain&quot;, &quot;loss&quot;), n, replace = TRUE))
})
char_mat = NULL
for(i in 1:10) {
	bed = bed_list[[i]]
	bed = bed[sample(nrow(bed), 20), , drop = FALSE]
	gr_cnv = GRanges(seqnames = bed[, 1], ranges = IRanges(bed[, 2], bed[, 3]))

	char_mat = cbind(char_mat, average_in_window(chr_window, gr_cnv, bed[, 4]))
}
</code></pre>
<p>The third data to visualize is simply genomic regions with two numeric columns where both columns
will be visualized as a point track and the first column will be visualized as a barplot track.</p>
<pre><code class="language-r">bed2 = generateRandomBed(nr = 100, nc = 2)
gr2 = GRanges(seqnames = bed2[, 1], ranges = IRanges(bed2[, 2], bed2[, 3]))

v = average_in_window(chr_window, gr2, bed2[, 4:5])
</code></pre>
<p>The fourth data to visualize is a list of gene symbols that we want to mark in
the plot. <code>gr3</code> contains genomic positions for the genes as well as their
symbols. The variable <code>at</code> contains the row indice of the corresponding
windows in <code>chr_window</code> and <code>labels</code> contains the gene names. As shown in the
following code, I simply use <code>findOverlaps()</code> to associate gene regions to
genomic windows.</p>
<pre><code class="language-r">bed3 = generateRandomBed(nr = 40, nc = 0)
gr3 = GRanges(seqnames = bed3[, 1], ranges = IRanges(bed3[, 2], bed3[, 2]))
gr3$gene = paste0(&quot;gene_&quot;, 1:length(gr3))

mtch = as.matrix(findOverlaps(chr_window, gr3))
at = mtch[, 1]
labels = mcols(gr3)[mtch[, 2], 1]
</code></pre>
<p>Now I have all the variables and are ready for making the heatmaps. Before doing that,
to better control the heatmap, I set <code>chr</code> as a factor to control the order of chromosomes
in the final plot and I create a variable <code>subgroup</code> to simulate the 10 columns in the matrix
for two subgroups.</p>
<pre><code class="language-r">chr = as.vector(seqnames(chr_window))
chr_level = paste0(&quot;chr&quot;, 1:22)
chr = factor(chr, levels = chr_level)

subgroup = rep(c(&quot;A&quot;, &quot;B&quot;), each = 5)
</code></pre>
<p>The following code makes the heatmap with additional tracks. The plot is a combination
of two heatmaps and three row annotations. Don&rsquo;t be scared by the massive number
of arguments. If you have been using <strong>ComplexHeatmap</strong> for more than a week, I believe
you&rsquo;ve already get used to it :).</p>
<pre><code class="language-r">library(ComplexHeatmap)
ht_opt$TITLE_PADDING = unit(c(4, 4), &quot;points&quot;)
ht_list = Heatmap(num_mat, name = &quot;mat&quot;, col = colorRamp2(c(-1, 0, 1), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)),
	row_split = chr, cluster_rows = FALSE, show_column_dend = FALSE,
	column_split = subgroup, cluster_column_slices = FALSE,
	column_title = &quot;numeric matrix&quot;,
	top_annotation = HeatmapAnnotation(subgroup = subgroup, annotation_name_side = &quot;left&quot;),
	row_title_rot = 0, row_title_gp = gpar(fontsize = 10), border = TRUE,
	row_gap = unit(0, &quot;points&quot;)) +
Heatmap(char_mat, name = &quot;CNV&quot;, col = c(&quot;gain&quot; = &quot;red&quot;, &quot;loss&quot; = &quot;blue&quot;),
	border = TRUE, column_title = &quot;character matrix&quot;) +
rowAnnotation(label = anno_mark(at = at, labels = labels)) +
rowAnnotation(pt = anno_points(v, gp = gpar(col = 4:5), pch = c(1, 16)), 
	width = unit(2, &quot;cm&quot;)) +
rowAnnotation(bar = anno_barplot(v[, 1], gp = gpar(col = ifelse(v[ ,1] &gt; 0, 2, 3))), 
	width = unit(2, &quot;cm&quot;))
draw(ht_list, merge_legend = TRUE)
</code></pre>
<img src="/lab-cn/post/2020-10-29-make-genome-scale-heatmap_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" />
<p>It is easy to make the arrangement of heatmaps vertical (use <code>%v%</code> to concatenate
heatmaps!). Just carefully switch the row-related parameters and
column-related parameters. Here I additinally adjust the legends to make them
look nicer in the plot.</p>
<p>Note I use a trick to arrange the chromosome names. Since the chromosome names will
overlap for small chromosomes, I simply add <code>\n</code> before or after for the neighbour chromosome names
(see how I set <code>column_title</code> argument in the first heatmap).</p>
<pre><code class="language-r">ht_list = Heatmap(t(num_mat), name = &quot;mat&quot;, col = colorRamp2(c(-1, 0, 1), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)),
	column_split = chr, cluster_columns = FALSE, show_row_dend = FALSE,
	row_split = subgroup, cluster_row_slices = FALSE,
	row_title = &quot;numeric matrix&quot;,
	left_annotation = rowAnnotation(subgroup = subgroup, show_annotation_name = FALSE,
		annotation_legend_param = list(
			subgroup = list(direction = &quot;horizontal&quot;, title_position = &quot;lefttop&quot;, nrow = 1))),
	column_title_gp = gpar(fontsize = 10), border = TRUE,
	column_gap = unit(0, &quot;points&quot;),
	column_title = ifelse(1:22 %% 2 == 0, paste0(&quot;\n&quot;, chr_level), paste0(chr_level, &quot;\n&quot;)),
	heatmap_legend_param = list(direction = &quot;horizontal&quot;, title_position = &quot;lefttop&quot;)) %v%
Heatmap(t(char_mat), name = &quot;CNV&quot;, col = c(&quot;gain&quot; = &quot;red&quot;, &quot;loss&quot; = &quot;blue&quot;),
	border = TRUE, row_title = &quot;character matrix&quot;,
	heatmap_legend_param = list(direction = &quot;horizontal&quot;, title_position = &quot;lefttop&quot;, nrow = 1)) %v%
HeatmapAnnotation(label = anno_mark(at = at, labels = labels, side = &quot;bottom&quot;)) %v%
HeatmapAnnotation(pt = anno_points(v, gp = gpar(col = 4:5), pch = c(1, 16)),
	annotation_name_side = &quot;left&quot;, height = unit(2, &quot;cm&quot;)) %v%
HeatmapAnnotation(bar = anno_barplot(v[, 1], gp = gpar(col = ifelse(v[ ,1] &gt; 0, 2, 3))), 
	annotation_name_side = &quot;left&quot;, height = unit(2, &quot;cm&quot;))
draw(ht_list, heatmap_legend_side = &quot;bottom&quot;, merge_legend = TRUE)
</code></pre>
<img src="/lab-cn/post/2020-10-29-make-genome-scale-heatmap_files/figure-html/unnamed-chunk-12-1.png" width="960" style="display: block; margin: auto;" />
<p>This is a new feature of <strong>ComplexHeatmap</strong>. If you have any comment on <code>average_in_window()</code> function
or on this post, I am very happy to listen!</p>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>
  $(document).ready(function(){
  $("img").css("display", "inline");
  $("main.content").css("max-width", "1000px");
});
</script>

  </div>

</section>


<style>
.footer p{
	color: #AAA;
	text-align: left;
	text-decoration: none;
	max-width:400px;
	border-top: 1px solid #AAA;
	padding-top:10px;
	font-size: 0.8em;
}
.footer p a {
	color: #AAA;
	text-align: left;
	text-decoration: none;
}
</style>

<footer class="footer">
<p>网站使用 <a href="https://gohugo.io/">Hugo</a>，<a href="https://bookdown.org/yihui/blogdown/">blogdown</a>，<a href="https://github.com/davidhampgonsalves/hugo-black-and-light-theme">Black & Light 主题</a>创建</p>
</footer>





<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>




<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>



